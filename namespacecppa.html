<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libcppa: cppa Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libcppa
   &#160;<span id="projectnumber">Version 0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cppa Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Root namespace of libcppa.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecppa_1_1exit__reason"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1exit__reason.html">exit_reason</a></td></tr>
<tr class="memdesc:namespacecppa_1_1exit__reason"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all predefined exit reasons. <br/></td></tr>
<tr class="memitem:namespacecppa_1_1factory"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1factory.html">factory</a></td></tr>
<tr class="memdesc:namespacecppa_1_1factory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains factory functions to create actors from lambdas or other functors. <br/></td></tr>
<tr class="memitem:namespacecppa_1_1intrusive"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1intrusive.html">intrusive</a></td></tr>
<tr class="memdesc:namespacecppa_1_1intrusive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains intrusive container implementations. <br/></td></tr>
<tr class="memitem:namespacecppa_1_1network"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1network.html">network</a></td></tr>
<tr class="memdesc:namespacecppa_1_1network"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all network related classes. <br/></td></tr>
<tr class="memitem:namespacecppa_1_1placeholders"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1placeholders.html">placeholders</a></td></tr>
<tr class="memdesc:namespacecppa_1_1placeholders"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the guard placeholders <code>_x1</code> to <code>_x9</code>. <br/></td></tr>
<tr class="memitem:namespacecppa_1_1util"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1util.html">util</a></td></tr>
<tr class="memdesc:namespacecppa_1_1util"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains utility classes and metaprogramming utilities used by the libcppa implementation. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor.html">actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all actor implementations.  <a href="classcppa_1_1actor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__addressing.html">actor_addressing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different serialization protocols have different representations for actors. This class encapsulates a technology-specific actor addressing.  <a href="classcppa_1_1actor__addressing.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__proxy.html">actor_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a remote actor.  <a href="classcppa_1_1actor__proxy.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a fixed-length copy-on-write tuple with elements of any type.  <a href="classcppa_1_1any__tuple.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1anything.html">anything</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acts as wildcard expression in patterns.  <a href="structcppa_1_1anything.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1is__anything.html">is_anything</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks wheter <code>T</code> is <a class="el" href="structcppa_1_1anything.html">anything</a>.  <a href="structcppa_1_1is__anything.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1attachable.html">attachable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback utility class.  <a href="classcppa_1_1attachable.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1behavior.html">behavior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the behavior of an actor.  <a href="classcppa_1_1behavior.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1binary__deserializer.html">binary_deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the deserializer interface with a binary serialization protocol.  <a href="classcppa_1_1binary__deserializer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1binary__serializer.html">binary_serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the serializer interface with a binary serialization protocol.  <a href="classcppa_1_1binary__serializer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1channel.html">channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for all message receivers.  <a href="classcppa_1_1channel.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1context__switching__actor.html">context_switching_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context-switching actor implementation.  <a href="classcppa_1_1context__switching__actor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1cow__ptr.html">cow_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy-on-write smart pointer implementation.  <a href="classcppa_1_1cow__ptr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1cow__tuple_3_01_head_00_01_tail_8_8_8_4.html">cow_tuple&lt; Head, Tail...&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-length copy-on-write cow_tuple.  <a href="classcppa_1_1cow__tuple_3_01_head_00_01_tail_8_8_8_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1deserializer.html">deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Technology-independent deserialization interface.  <a href="classcppa_1_1deserializer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1either.html">either</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents either a <code>Left</code> or a <code>Right</code>.  <a href="classcppa_1_1either.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1enable__weak__ptr__mixin.html">enable_weak_ptr_mixin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables derived classes to be used in <a class="el" href="classcppa_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a>.  <a href="classcppa_1_1enable__weak__ptr__mixin.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1event__based__actor.html">event_based_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all event-based actor implementations.  <a href="classcppa_1_1event__based__actor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1cppa__exception.html">cppa_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for libcppa exceptions.  <a href="classcppa_1_1cppa__exception.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__exited.html">actor_exited</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown if an actor finished execution.  <a href="classcppa_1_1actor__exited.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1network__error.html">network_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown to indicate that either an actor publishing failed or <code>libcppa</code> was unable to connect to a remote host.  <a href="classcppa_1_1network__error.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1bind__failure.html">bind_failure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown to indicate that an actor publishing failed because the requested port could not be used.  <a href="classcppa_1_1bind__failure.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1group.html">group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multicast group.  <a href="classcppa_1_1group.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1guard__placeholder.html">guard_placeholder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for guard expression.  <a href="structcppa_1_1guard__placeholder.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An intrusive, reference counting smart pointer impelementation.  <a href="classcppa_1_1intrusive__ptr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1local__actor.html">local_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for local running Actors.  <a href="classcppa_1_1local__actor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1message__future.html">message_future</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the result of a synchronous send.  <a href="classcppa_1_1message__future.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1message__id__t.html">message_id_t</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1object.html">object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction class that stores an instance of an announced type.  <a href="classcppa_1_1object.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1option.html">option</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an optional value of <code>T</code>.  <a href="classcppa_1_1option.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1partial__function.html">partial_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial function implementation for <a class="el" href="classcppa_1_1any__tuple.html">any_tuples</a>.  <a href="classcppa_1_1partial__function.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1pattern.html">pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern matching for type and optionally value of tuple elements.  <a href="classcppa_1_1pattern.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An union container for primitive data types.  <a href="classcppa_1_1primitive__variant.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1process__information.html">process_information</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a process.  <a href="classcppa_1_1process__information.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1ref__counted.html">ref_counted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (thread safe) base class for reference counted objects with an atomic reference count.  <a href="classcppa_1_1ref__counted.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1sb__actor.html">sb_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for state-based actors using the Curiously Recurring Template Pattern to initialize the derived actor with its <code>init_state</code> member.  <a href="classcppa_1_1sb__actor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1scheduled__actor.html">scheduled_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for cooperatively scheduled actors.  <a href="classcppa_1_1scheduled__actor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1serializer.html">serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Technology-independent serialization interface.  <a href="classcppa_1_1serializer.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1thread__mapped__actor.html">thread_mapped_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An actor running in its own thread.  <a href="classcppa_1_1thread__mapped__actor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a platform independent type name and a (very primitive) kind of reflection in combination with <a class="el" href="classcppa_1_1object.html">object</a>.  <a href="classcppa_1_1uniform__type__info.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer that does not increase the reference count.  <a href="classcppa_1_1weak__intrusive__ptr.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1weak__ptr__anchor.html">weak_ptr_anchor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A storage holding a spinlock and a pointer to a reference counted object.  <a href="classcppa_1_1weak__ptr__anchor.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a948e3ea11df8e64e9a0e0204d3d52539"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a948e3ea11df8e64e9a0e0204d3d52539"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>native_socket_type</b></td></tr>
<tr class="memitem:af8212243ffb4995abddd7850f47863b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8212243ffb4995abddd7850f47863b1"></a>
typedef const void *&#160;</td><td class="memItemRight" valign="bottom"><b>socket_send_ptr</b></td></tr>
<tr class="memitem:a41cea4187e4fa345b7cad0ca5c8e08af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41cea4187e4fa345b7cad0ca5c8e08af"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><b>socket_recv_ptr</b></td></tr>
<tr class="memitem:aa911b41078aff43f355b1d64dc4b7475"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa911b41078aff43f355b1d64dc4b7475"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcppa_1_1actor.html">actor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>actor_ptr</b></td></tr>
<tr class="memitem:a60ee2cb32752d31e00d020c6cb7362e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60ee2cb32752d31e00d020c6cb7362e2"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcppa_1_1group.html">group</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>group_ptr</b></td></tr>
<tr class="memitem:a0ac06fc2f69fb1021d95310238161c4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ac06fc2f69fb1021d95310238161c4e"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcppa_1_1channel.html">channel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>channel_ptr</b></td></tr>
<tr class="memitem:a46190b719f248a02b0dcf748ac76b10f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46190b719f248a02b0dcf748ac76b10f"></a>
typedef behavior_policy&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keep_behavior_t</b></td></tr>
<tr class="memitem:a7ea2a0fe3f2f2a7f451d667a22b5940e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ea2a0fe3f2f2a7f451d667a22b5940e"></a>
typedef behavior_policy&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>discard_behavior_t</b></td></tr>
<tr class="memitem:a748ba4e6851a7452f97ef907fe1c8393"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a748ba4e6851a7452f97ef907fe1c8393"></a>
typedef std::map&lt; std::string, <br class="typebreak"/>
std::map&lt; std::pair&lt; char, <br class="typebreak"/>
std::string &gt;, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>options_description</b></td></tr>
<tr class="memitem:ae02290ba27f0e00874bd507875e460e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae02290ba27f0e00874bd507875e460e2"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classcppa_1_1scheduled__actor.html">scheduled_actor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>scheduled_actor_ptr</b></td></tr>
<tr class="memitem:aa31987abf5e99588083a59e5ce5b9d13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa31987abf5e99588083a59e5ce5b9d13"></a>
typedef std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>void_function</b></td></tr>
<tr class="memitem:ad51bd7677d1df2d8b7b280ff5607ee46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad51bd7677d1df2d8b7b280ff5607ee46"></a>
typedef std::function&lt; void(<a class="el" href="classcppa_1_1local__actor.html">local_actor</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>init_callback</b></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5dd69804058d7adaef774fd953c63b97"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5dd69804058d7adaef774fd953c63b97">atom_value</a> { <b>dirty_little_hack</b> =  37337
 }</td></tr>
<tr class="memdesc:a5dd69804058d7adaef774fd953c63b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type of atoms. <br/></td></tr>
<tr class="memitem:ae32a52f8d2b456d1b5dbd2d0a3d3df34"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>operator_id</b> { <br/>
&#160;&#160;<b>addition_op</b>, 
<br/>
&#160;&#160;<b>subtraction_op</b>, 
<br/>
&#160;&#160;<b>multiplication_op</b>, 
<br/>
&#160;&#160;<b>division_op</b>, 
<br/>
&#160;&#160;<b>modulo_op</b>, 
<br/>
&#160;&#160;<b>less_op</b>, 
<br/>
&#160;&#160;<b>less_eq_op</b>, 
<br/>
&#160;&#160;<b>greater_op</b>, 
<br/>
&#160;&#160;<b>greater_eq_op</b>, 
<br/>
&#160;&#160;<b>equal_op</b>, 
<br/>
&#160;&#160;<b>not_equal_op</b>, 
<br/>
&#160;&#160;<b>logical_and_op</b>, 
<br/>
&#160;&#160;<b>logical_or_op</b>, 
<br/>
&#160;&#160;<b>exec_fun1_op</b>, 
<br/>
&#160;&#160;<b>exec_fun2_op</b>, 
<br/>
&#160;&#160;<b>exec_fun3_op</b>, 
<br/>
&#160;&#160;<b>exec_xfun_op</b>, 
<br/>
&#160;&#160;<b>dummy_op</b>
<br/>
 }</td></tr>
<tr class="memitem:a5ab63f2274711ea5cce959c91d793b25"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5ab63f2274711ea5cce959c91d793b25">wildcard_position</a> { <br/>
&#160;&#160;<b>nil</b>, 
<br/>
&#160;&#160;<b>trailing</b>, 
<br/>
&#160;&#160;<b>leading</b>, 
<br/>
&#160;&#160;<b>in_between</b>, 
<br/>
&#160;&#160;<b>multiple</b>
<br/>
 }</td></tr>
<tr class="memdesc:a5ab63f2274711ea5cce959c91d793b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes the position of <a class="el" href="structcppa_1_1anything.html">anything</a> in a template parameter pack. <br/></td></tr>
<tr class="memitem:ga5a8afa49a3547b610d4a50b3ab1dceb6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga5a8afa49a3547b610d4a50b3ab1dceb6">primitive_type</a> { <br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6af3b4cd07f6e7b784ef327226d125f081">pt_int8</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6abe2fbca2e1841f8c22880cde2c00f542">pt_int16</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6aa0a3077bf98838f8565a3081bd45fe7a">pt_int32</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6adb00d323a0719b09a9b1e2b296bf7ee7">pt_int64</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6a88cb8022596d4673fede279849a67c9e">pt_uint8</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6ac2fefdb86c724a8fccdaf77295bdb786">pt_uint16</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6a081be63f60008807f9a07df1d814704a">pt_uint32</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6a05e7b1ff7b99a9f24ff8a44577745d59">pt_uint64</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6a9c2885b0dd3095de04714bf6d791ed61">pt_float</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6a840b02ba715ef3b798d3f1b6cb1dd1bc">pt_double</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6afaa2282a22514a0934a3571b4e4cc75d">pt_long_double</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6a93531ba3275cbc0a4cfcb23a6bbe080e">pt_u8string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6ab2a366dcc7a5b7ee1162fd024d6f722e">pt_u16string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6ac04250078e159cbbb285ad3a39aae4ce">pt_u32string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga5a8afa49a3547b610d4a50b3ab1dceb6a494ed640f1e094e7db23a9ce2f3f199b">pt_null</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga5a8afa49a3547b610d4a50b3ab1dceb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type flag of <a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a>.  <a href="group___type_system.html#ga5a8afa49a3547b610d4a50b3ab1dceb6">More...</a><br/></td></tr>
<tr class="memitem:af816c542cfd937e5e9da9c9b88304c43"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>resume_result</b> { <br/>
&#160;&#160;<b>actor_blocked</b>, 
<br/>
&#160;&#160;<b>actor_done</b>
<br/>
 }</td></tr>
<tr class="memitem:a5170d2d86c130ef4375778aa90aec596"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>scheduled_actor_type</b> { <br/>
&#160;&#160;<b>context_switching_impl</b>, 
<br/>
&#160;&#160;<b>event_based_impl</b>
<br/>
 }</td></tr>
<tr class="memitem:ada43001c9a9dd2cbb1f87656b7fa1cb4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ada43001c9a9dd2cbb1f87656b7fa1cb4">scheduling_hint</a> { <br/>
&#160;&#160;<a class="el" href="namespacecppa.html#ada43001c9a9dd2cbb1f87656b7fa1cb4aceac3de2f38c06f50912d1870df54d55">scheduled</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacecppa.html#ada43001c9a9dd2cbb1f87656b7fa1cb4aa095bad54a9491227ae34ec4e8036eed">detached</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacecppa.html#ada43001c9a9dd2cbb1f87656b7fa1cb4a855c80d325a3d15c95b310a3a4f7528c">detached_and_hidden</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacecppa.html#ada43001c9a9dd2cbb1f87656b7fa1cb4ac5633e6e80b07bfbea04d091909ab35e">scheduled_and_hidden</a>
<br/>
 }</td></tr>
<tr class="memdesc:ada43001c9a9dd2cbb1f87656b7fa1cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes whether a user wants an actor to take part in cooperative scheduling or not.  <a href="namespacecppa.html#ada43001c9a9dd2cbb1f87656b7fa1cb4">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2db736f11be49eb6571e67b8616d4708"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2db736f11be49eb6571e67b8616d4708"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> &amp;lhs, const self_type &amp;rhs)</td></tr>
<tr class="memitem:a8c642e17c6f1ef15fe1a416343df4b71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c642e17c6f1ef15fe1a416343df4b71"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const self_type &amp;lhs, const <a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> &amp;rhs)</td></tr>
<tr class="memitem:ga7f73c466e0356b08161d77769aeb726f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga7f73c466e0356b08161d77769aeb726f">announce</a> (const std::type_info &amp;tinfo, <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> *utype)</td></tr>
<tr class="memdesc:ga7f73c466e0356b08161d77769aeb726f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new type mapping to the libcppa type system.  <a href="group___type_system.html#ga7f73c466e0356b08161d77769aeb726f"></a><br/></td></tr>
<tr class="memitem:ga14b48aea5fb9e90bcf0a4bda12f3072c"><td class="memTemplParams" colspan="2">template&lt;class C , class Parent , typename... Args&gt; </td></tr>
<tr class="memitem:ga14b48aea5fb9e90bcf0a4bda12f3072c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; C Parent::*, <br class="typebreak"/>
<a class="el" href="classcppa_1_1util_1_1abstract__uniform__type__info.html">util::abstract_uniform_type_info</a><br class="typebreak"/>
&lt; C &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga14b48aea5fb9e90bcf0a4bda12f3072c">compound_member</a> (C Parent::*c_ptr, const Args &amp;...args)</td></tr>
<tr class="memdesc:ga14b48aea5fb9e90bcf0a4bda12f3072c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member <code>C</code>.  <a href="group___type_system.html#ga14b48aea5fb9e90bcf0a4bda12f3072c"></a><br/></td></tr>
<tr class="memitem:ga012a786624d76e283f6118253f0689c0"><td class="memTemplParams" colspan="2">template&lt;class C , class Parent , typename... Args&gt; </td></tr>
<tr class="memitem:ga012a786624d76e283f6118253f0689c0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; C &amp;(Parent::*)(), <br class="typebreak"/>
<a class="el" href="classcppa_1_1util_1_1abstract__uniform__type__info.html">util::abstract_uniform_type_info</a><br class="typebreak"/>
&lt; C &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga012a786624d76e283f6118253f0689c0">compound_member</a> (C &amp;(Parent::*getter)(), const Args &amp;...args)</td></tr>
<tr class="memdesc:ga012a786624d76e283f6118253f0689c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member accessed via a getter returning a mutable reference.  <a href="group___type_system.html#ga012a786624d76e283f6118253f0689c0"></a><br/></td></tr>
<tr class="memitem:ga94c718de23623e2e2d614a5e0a62d0a8"><td class="memTemplParams" colspan="2">template&lt;class Parent , typename GRes , typename SRes , typename SArg , typename... Args&gt; </td></tr>
<tr class="memitem:ga94c718de23623e2e2d614a5e0a62d0a8"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; GRes(Parent::*)() <br class="typebreak"/>
const, SRes(Parent::*)(SArg)&gt;<br class="typebreak"/>
, <a class="el" href="classcppa_1_1util_1_1abstract__uniform__type__info.html">util::abstract_uniform_type_info</a><br class="typebreak"/>
&lt; typename <a class="el" href="structcppa_1_1util_1_1rm__ref.html">util::rm_ref</a>&lt; GRes &gt;<br class="typebreak"/>
::type &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga94c718de23623e2e2d614a5e0a62d0a8">compound_member</a> (const std::pair&lt; GRes(Parent::*)() const, SRes(Parent::*)(SArg) &gt; &amp;gspair, const Args &amp;...args)</td></tr>
<tr class="memdesc:ga94c718de23623e2e2d614a5e0a62d0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member accessed via a getter/setter pair.  <a href="group___type_system.html#ga94c718de23623e2e2d614a5e0a62d0a8"></a><br/></td></tr>
<tr class="memitem:gacb2a06b208db48f0c7c79740702e7e61"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:gacb2a06b208db48f0c7c79740702e7e61"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#gacb2a06b208db48f0c7c79740702e7e61">announce</a> (const Args &amp;...args)</td></tr>
<tr class="memdesc:gacb2a06b208db48f0c7c79740702e7e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new type mapping for <code>T</code> to the libcppa type system.  <a href="group___type_system.html#gacb2a06b208db48f0c7c79740702e7e61"></a><br/></td></tr>
<tr class="memitem:a7d0ed8b8c047b52ff833c8315b1bf963"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7d0ed8b8c047b52ff833c8315b1bf963"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a7d0ed8b8c047b52ff833c8315b1bf963">make_any_tuple</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a7d0ed8b8c047b52ff833c8315b1bf963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> containing the elements <code>args</code>.  <a href="#a7d0ed8b8c047b52ff833c8315b1bf963"></a><br/></td></tr>
<tr class="memitem:a76a9f2873d0e97eb7ceffb6101e8e507"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a76a9f2873d0e97eb7ceffb6101e8e507">to_string</a> (const <a class="el" href="namespacecppa.html#a5dd69804058d7adaef774fd953c63b97">atom_value</a> &amp;what)</td></tr>
<tr class="memdesc:a76a9f2873d0e97eb7ceffb6101e8e507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>what</code> as a string representation.  <a href="#a76a9f2873d0e97eb7ceffb6101e8e507"></a><br/></td></tr>
<tr class="memitem:a9ed5b5aa07c384b14899beae80974d47"><td class="memTemplParams" colspan="2">template&lt;size_t Size&gt; </td></tr>
<tr class="memitem:a9ed5b5aa07c384b14899beae80974d47"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecppa.html#a5dd69804058d7adaef774fd953c63b97">atom_value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47">atom</a> (char const (&amp;str)[Size])</td></tr>
<tr class="memdesc:a9ed5b5aa07c384b14899beae80974d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an atom from given string literal.  <a href="#a9ed5b5aa07c384b14899beae80974d47"></a><br/></td></tr>
<tr class="memitem:aec43546449dfb9ee7dff217cbe6dbf87"><td class="memTemplParams" colspan="2"><a class="anchor" id="aec43546449dfb9ee7dff217cbe6dbf87"></a>
template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:aec43546449dfb9ee7dff217cbe6dbf87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcppa_1_1util_1_1if__else.html">util::if_else</a><br class="typebreak"/>
&lt; util::disjunction<br class="typebreak"/>
&lt; is_timeout_definition&lt; Arg0 &gt;<br class="typebreak"/>
, is_timeout_definition&lt; Args &gt;<br class="typebreak"/>
...&gt;, <a class="el" href="classcppa_1_1behavior.html">behavior</a>, <a class="el" href="structcppa_1_1util_1_1wrapped.html">util::wrapped</a><br class="typebreak"/>
&lt; <a class="el" href="classcppa_1_1partial__function.html">partial_function</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_convert</b> (const Arg0 &amp;arg0, const Args &amp;...args)</td></tr>
<tr class="memitem:aca28f3fe16f1c4f5e027401a1f574b5a"><td class="memTemplParams" colspan="2"><a class="anchor" id="aca28f3fe16f1c4f5e027401a1f574b5a"></a>
template&lt;typename... Lhs, typename F &gt; </td></tr>
<tr class="memitem:aca28f3fe16f1c4f5e027401a1f574b5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1behavior.html">behavior</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator,</b> (const match_expr&lt; Lhs...&gt; &amp;lhs, const timeout_definition&lt; F &gt; &amp;rhs)</td></tr>
<tr class="memitem:a41f35f5fe58e287026a0149f341e8e3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41f35f5fe58e287026a0149f341e8e3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>closesocket</b> (native_socket_type fd)</td></tr>
<tr class="memitem:a185090573ffb146384ccdfa94172c23e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a185090573ffb146384ccdfa94172c23e">await_all_others_done</a> ()</td></tr>
<tr class="memdesc:a185090573ffb146384ccdfa94172c23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks execution of this actor until all other actors finished execution.  <a href="#a185090573ffb146384ccdfa94172c23e"></a><br/></td></tr>
<tr class="memitem:a487e6c08f5f4f7de4775418547f7e93e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a487e6c08f5f4f7de4775418547f7e93e">publish</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> whom, std::uint16_t port, const char *addr=nullptr)</td></tr>
<tr class="memdesc:a487e6c08f5f4f7de4775418547f7e93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publishes <code>whom</code> at <code>port</code>.  <a href="#a487e6c08f5f4f7de4775418547f7e93e"></a><br/></td></tr>
<tr class="memitem:ad9c73df0929df9b069096d3d9f9499bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ad9c73df0929df9b069096d3d9f9499bf">publish</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> whom, std::unique_ptr&lt; <a class="el" href="classcppa_1_1network_1_1acceptor.html">network::acceptor</a> &gt; acceptor)</td></tr>
<tr class="memdesc:ad9c73df0929df9b069096d3d9f9499bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publishes <code>whom</code> using <code>acceptor</code> to handle incoming connections.  <a href="#ad9c73df0929df9b069096d3d9f9499bf"></a><br/></td></tr>
<tr class="memitem:a76739f7f372b92999ee9b80d332093bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a76739f7f372b92999ee9b80d332093bd">remote_actor</a> (const char *host, std::uint16_t port)</td></tr>
<tr class="memdesc:a76739f7f372b92999ee9b80d332093bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to the actor at <code>host</code> on given <code>port</code>.  <a href="#a76739f7f372b92999ee9b80d332093bd"></a><br/></td></tr>
<tr class="memitem:a1e44ab5ef88ac98dd909f3a09bbf181d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a1e44ab5ef88ac98dd909f3a09bbf181d">remote_actor</a> (const std::string &amp;host, std::uint16_t port)</td></tr>
<tr class="memdesc:a1e44ab5ef88ac98dd909f3a09bbf181d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to the actor at <code>host</code> on given <code>port</code>.   <a href="#a1e44ab5ef88ac98dd909f3a09bbf181d"></a><br/></td></tr>
<tr class="memitem:aa39f7d863455eec31681ebd1879e4fd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aa39f7d863455eec31681ebd1879e4fd6">remote_actor</a> (<a class="el" href="namespacecppa_1_1network.html#a4615e80cb9a1a5925e5598b46348afc2">network::io_stream_ptr_pair</a> connection)</td></tr>
<tr class="memdesc:aa39f7d863455eec31681ebd1879e4fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to the actor via given <code>connection</code>.  <a href="#aa39f7d863455eec31681ebd1879e4fd6"></a><br/></td></tr>
<tr class="memitem:a8d5daac288a10cc34286f505ea637571"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d5daac288a10cc34286f505ea637571"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a8d5daac288a10cc34286f505ea637571">shutdown</a> ()</td></tr>
<tr class="memdesc:a8d5daac288a10cc34286f505ea637571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all singletons, disconnects all peers and stops the scheduler. It is recommended to use this function as very last function call before leaving main(). Especially in programs using libcppa's networking infrastructure. <br/></td></tr>
<tr class="memitem:aaa221547ef879ba5b42f7cc7820f90e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aaa221547ef879ba5b42f7cc7820f90e1">from_string</a> (const std::string &amp;what)</td></tr>
<tr class="memdesc:aaa221547ef879ba5b42f7cc7820f90e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string created by <a class="el" href="namespacecppa.html#a76a9f2873d0e97eb7ceffb6101e8e507">to_string</a> to its original value.  <a href="#aaa221547ef879ba5b42f7cc7820f90e1"></a><br/></td></tr>
<tr class="memitem:ae213a56201820111919afe92aa287586"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ae213a56201820111919afe92aa287586">publish_local_groups_at</a> (std::uint16_t port, const char *addr=nullptr)</td></tr>
<tr class="memdesc:ae213a56201820111919afe92aa287586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <em>all</em> local groups accessible via network on address <code>addr</code> and <code>port</code>.  <a href="#ae213a56201820111919afe92aa287586"></a><br/></td></tr>
<tr class="memitem:aed3c7758be0a4d0f89cffda5ba392079"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed3c7758be0a4d0f89cffda5ba392079"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed3c7758be0a4d0f89cffda5ba392079"><td class="memTemplItemLeft" align="right" valign="top">ge_reference_wrapper&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aed3c7758be0a4d0f89cffda5ba392079">gref</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aed3c7758be0a4d0f89cffda5ba392079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reference wrapper similar to std::reference_wrapper&lt;const T&gt; that could be used in guard expressions or to enforce lazy evaluation. <br/></td></tr>
<tr class="memitem:aef395eaa7bd389ba17e28867010b5a7e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aef395eaa7bd389ba17e28867010b5a7e"></a>
template&lt;typename Fun , typename T1 &gt; </td></tr>
<tr class="memitem:aef395eaa7bd389ba17e28867010b5a7e"><td class="memTemplItemLeft" align="right" valign="top">gcall1&lt; Fun, T1 &gt;::result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aef395eaa7bd389ba17e28867010b5a7e">gcall</a> (Fun fun, T1 t1)</td></tr>
<tr class="memdesc:aef395eaa7bd389ba17e28867010b5a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call wrapper for guard placeholders and lazy evaluation. <br/></td></tr>
<tr class="memitem:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a444ff11a730b8c1d42d5499c8fd36ed0"></a>
template&lt;typename Fun , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="memTemplItemLeft" align="right" valign="top">gcall2&lt; Fun, T1, T2 &gt;::result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a444ff11a730b8c1d42d5499c8fd36ed0">gcall</a> (Fun fun, T1 t1, T2 t2)</td></tr>
<tr class="memdesc:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call wrapper for guard placeholders and lazy evaluation. <br/></td></tr>
<tr class="memitem:afb38db3897563dd010b0159b7598ce24"><td class="memTemplParams" colspan="2"><a class="anchor" id="afb38db3897563dd010b0159b7598ce24"></a>
template&lt;typename Fun , typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:afb38db3897563dd010b0159b7598ce24"><td class="memTemplItemLeft" align="right" valign="top">gcall3&lt; Fun, T1, T2, T3 &gt;::result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#afb38db3897563dd010b0159b7598ce24">gcall</a> (Fun fun, T1 t1, T2 t2, T3 t3)</td></tr>
<tr class="memdesc:afb38db3897563dd010b0159b7598ce24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call wrapper for guard placeholders and lazy evaluation. <br/></td></tr>
<tr class="memitem:a11ca2ae4516ac8c2d09825bf16e06399"><td class="memTemplParams" colspan="2"><a class="anchor" id="a11ca2ae4516ac8c2d09825bf16e06399"></a>
template&lt;typename Fun &gt; </td></tr>
<tr class="memitem:a11ca2ae4516ac8c2d09825bf16e06399"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; exec_xfun_op, Fun, <br class="typebreak"/>
util::void_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a11ca2ae4516ac8c2d09825bf16e06399">ge_sub_function</a> (Fun fun)</td></tr>
<tr class="memdesc:a11ca2ae4516ac8c2d09825bf16e06399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>fun</code> with all arguments given to the guard expression. The functor <code>fun</code> must return a boolean. <br/></td></tr>
<tr class="memitem:aee6efd772c183821806213315e16c30c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aee6efd772c183821806213315e16c30c"></a>
template&lt;operator_id OP, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aee6efd772c183821806213315e16c30c"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; OP, typename <br class="typebreak"/>
detail::strip_and_convert&lt; T1 &gt;<br class="typebreak"/>
::type, typename <br class="typebreak"/>
detail::strip_and_convert&lt; T2 &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_concatenate</b> (T1 first, T2 second, typename std::enable_if&lt; is_ge_type&lt; T1 &gt;::value||is_ge_type&lt; T2 &gt;::value &gt;::type *=0)</td></tr>
<tr class="memitem:a55ae21ec736d7c79de5bc814efab66ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a55ae21ec736d7c79de5bc814efab66ca"></a>
template&lt;operator_id OP1, typename F1 , typename S1 , operator_id OP2, typename F2 , typename S2 &gt; </td></tr>
<tr class="memitem:a55ae21ec736d7c79de5bc814efab66ca"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; logical_and_op, <br class="typebreak"/>
guard_expr&lt; OP1, F1, S1 &gt;<br class="typebreak"/>
, guard_expr&lt; OP2, F2, S2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (guard_expr&lt; OP1, F1, S1 &gt; lhs, guard_expr&lt; OP2, F2, S2 &gt; rhs)</td></tr>
<tr class="memitem:a628c9ea9c68a69a765e1c22ebab625b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a628c9ea9c68a69a765e1c22ebab625b9"></a>
template&lt;operator_id OP1, typename F1 , typename S1 , operator_id OP2, typename F2 , typename S2 &gt; </td></tr>
<tr class="memitem:a628c9ea9c68a69a765e1c22ebab625b9"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; logical_or_op, <br class="typebreak"/>
guard_expr&lt; OP1, F1, S1 &gt;<br class="typebreak"/>
, guard_expr&lt; OP2, F2, S2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (guard_expr&lt; OP1, F1, S1 &gt; lhs, guard_expr&lt; OP2, F2, S2 &gt; rhs)</td></tr>
<tr class="memitem:a3df0ac35ccc8aca49cfd042f977a375b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3df0ac35ccc8aca49cfd042f977a375b"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:a3df0ac35ccc8aca49cfd042f977a375b"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const T &amp;value)</td></tr>
<tr class="memitem:a44077174990342ce322b5c720af285a7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a44077174990342ce322b5c720af285a7"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:a44077174990342ce322b5c720af285a7"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const std::reference_wrapper&lt; T &gt; &amp;value)</td></tr>
<tr class="memitem:a2f4027bf874a6ff4ad23d688ffe08544"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f4027bf874a6ff4ad23d688ffe08544"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:a2f4027bf874a6ff4ad23d688ffe08544"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const std::reference_wrapper&lt; const T &gt; &amp;value)</td></tr>
<tr class="memitem:a2d58c827a376e3012d7e680449bf5e38"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2d58c827a376e3012d7e680449bf5e38"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:a2d58c827a376e3012d7e680449bf5e38"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const ge_reference_wrapper&lt; T &gt; &amp;value)</td></tr>
<tr class="memitem:a610bcac87bd4033b93696039d093bfa8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a610bcac87bd4033b93696039d093bfa8"></a>
template&lt;class Tuple , int X&gt; </td></tr>
<tr class="memitem:a610bcac87bd4033b93696039d093bfa8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;tup, <a class="el" href="structcppa_1_1guard__placeholder.html">guard_placeholder</a>&lt; X &gt;)-&gt; decltype(get&lt; X &gt;(tup).get())</td></tr>
<tr class="memitem:ae9261422d14f881dbf805a8a124325b0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae9261422d14f881dbf805a8a124325b0"></a>
template&lt;class Tuple , operator_id OP, typename First , typename Second &gt; </td></tr>
<tr class="memitem:ae9261422d14f881dbf805a8a124325b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;tup, const guard_expr&lt; OP, First, Second &gt; &amp;ge)-&gt; typename ge_result&lt; OP</td></tr>
<tr class="memitem:a3c3c9b3d2cf91e86fbefa608b71b6ed1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c3c9b3d2cf91e86fbefa608b71b6ed1"></a>
template&lt;operator_id OP, class Tuple , typename First , typename Second &gt; </td></tr>
<tr class="memitem:a3c3c9b3d2cf91e86fbefa608b71b6ed1"><td class="memTemplItemLeft" align="right" valign="top">ge_result&lt; OP, First, Second, <br class="typebreak"/>
Tuple &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_eval</b> (const Tuple &amp;tup, const First &amp;lhs, const Second &amp;rhs)</td></tr>
<tr class="memitem:a3e2bcb1c2105c3fa3c7b043bbd451f91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e2bcb1c2105c3fa3c7b043bbd451f91"></a>
typename Args auto&#160;</td><td class="memItemRight" valign="bottom"><b>ge_invoke_step2</b> (const guard_expr&lt; OP, First, Second &gt; &amp;ge, const detail::tdata&lt; Args...&gt; &amp;tup)-&gt; typename ge_result&lt; OP</td></tr>
<tr class="memitem:a7d8bbbc928676d4f7d787068ba14d68f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d8bbbc928676d4f7d787068ba14d68f"></a>
typename Args auto&#160;</td><td class="memItemRight" valign="bottom"><b>ge_invoke</b> (const guard_expr&lt; OP, First, Second &gt; &amp;ge, const Args &amp;...args)-&gt; typename ge_result&lt; OP</td></tr>
<tr class="memitem:ab2a82a93906c827b7ada3f6ffe195a56"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2a82a93906c827b7ada3f6ffe195a56"></a>
template&lt;typename TupleTypes , operator_id OP, typename First , typename Second &gt; </td></tr>
<tr class="memitem:ab2a82a93906c827b7ada3f6ffe195a56"><td class="memTemplItemLeft" align="right" valign="top">ge_result&lt; OP, First, Second, <br class="typebreak"/>
typename <br class="typebreak"/>
detail::tdata_from_type_list<br class="typebreak"/>
&lt; typename util::tl_filter_not<br class="typebreak"/>
&lt; TupleTypes, <a class="el" href="structcppa_1_1is__anything.html">is_anything</a> &gt;<br class="typebreak"/>
::type &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_invoke_any</b> (const guard_expr&lt; OP, First, Second &gt; &amp;ge, const <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> &amp;tup)</td></tr>
<tr class="memitem:ad9a68bcc41e0df87663196f06f274246"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad9a68bcc41e0df87663196f06f274246"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ad9a68bcc41e0df87663196f06f274246"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ad9a68bcc41e0df87663196f06f274246">make_counted</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ad9a68bcc41e0df87663196f06f274246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T which must be a derived type of <a class="el" href="classcppa_1_1ref__counted.html">ref_counted</a> and wraps it in an <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>. <br/></td></tr>
<tr class="memitem:ad65859efc090932630d14b226b9c9624"><td class="memItemLeft" align="right" valign="top">detail::match_helper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ad65859efc090932630d14b226b9c9624">match</a> (<a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:ad65859efc090932630d14b226b9c9624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression.  <a href="#ad65859efc090932630d14b226b9c9624"></a><br/></td></tr>
<tr class="memitem:adaa18a8117e9022caea2b0606c11ebbc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adaa18a8117e9022caea2b0606c11ebbc"><td class="memTemplItemLeft" align="right" valign="top">detail::match_helper&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#adaa18a8117e9022caea2b0606c11ebbc">match</a> (T &amp;&amp;what)</td></tr>
<tr class="memdesc:adaa18a8117e9022caea2b0606c11ebbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression.   <a href="#adaa18a8117e9022caea2b0606c11ebbc"></a><br/></td></tr>
<tr class="memitem:a190b08703616bd22402836fcb24033a9"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a190b08703616bd22402836fcb24033a9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a190b08703616bd22402836fcb24033a9">match_each</a> (InputIterator first, InputIterator last)-&gt; detail</td></tr>
<tr class="memdesc:a190b08703616bd22402836fcb24033a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression that matches each element in range [first, last).  <a href="#a190b08703616bd22402836fcb24033a9"></a><br/></td></tr>
<tr class="memitem:abd625f5c7c3705bb7c951c425ce96469"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Projection &gt; </td></tr>
<tr class="memitem:abd625f5c7c3705bb7c951c425ce96469"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#abd625f5c7c3705bb7c951c425ce96469">match_each</a> (InputIterator first, InputIterator last, Projection proj)-&gt; detail</td></tr>
<tr class="memdesc:abd625f5c7c3705bb7c951c425ce96469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression that matches <code>proj(i)</code> for each element <code>i</code> in range [first, last).  <a href="#abd625f5c7c3705bb7c951c425ce96469"></a><br/></td></tr>
<tr class="memitem:a691cdf8a8d7d0c1383db2c231a518052"><td class="memTemplParams" colspan="2"><a class="anchor" id="a691cdf8a8d7d0c1383db2c231a518052"></a>
template&lt;typename InputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a691cdf8a8d7d0c1383db2c231a518052"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_for</b> (InputIterator first, Predicate pred)-&gt; detail</td></tr>
<tr class="memitem:a630bd6ec90c87e3770f50815ce19effd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a630bd6ec90c87e3770f50815ce19effd"></a>
template&lt;typename InputIterator , typename Predicate , typename Advance &gt; </td></tr>
<tr class="memitem:a630bd6ec90c87e3770f50815ce19effd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_for</b> (InputIterator first, Predicate pred, Advance adv)-&gt; detail</td></tr>
<tr class="memitem:a0beedc855a6e76ff1cfbce48c6291361"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0beedc855a6e76ff1cfbce48c6291361"></a>
template&lt;class InputIterator , class Predicate , class Advance , class Projection &gt; </td></tr>
<tr class="memitem:a0beedc855a6e76ff1cfbce48c6291361"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_for</b> (InputIterator first, Predicate pred, Advance adv, Projection pj)-&gt; detail</td></tr>
<tr class="memitem:a9e1f7de88c500126cd7626401724d10b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e1f7de88c500126cd7626401724d10b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e1f7de88c500126cd7626401724d10b"><td class="memTemplItemLeft" align="right" valign="top">detail::stream_matcher&lt; T, <br class="typebreak"/>
std::istream_iterator&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_stream</b> (std::istream &amp;stream)</td></tr>
<tr class="memitem:a92e87041ae91c323107ec8a2cc269762"><td class="memTemplParams" colspan="2"><a class="anchor" id="a92e87041ae91c323107ec8a2cc269762"></a>
template&lt;typename T , typename InputIterator &gt; </td></tr>
<tr class="memitem:a92e87041ae91c323107ec8a2cc269762"><td class="memTemplItemLeft" align="right" valign="top">detail::stream_matcher&lt; T, <br class="typebreak"/>
InputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_stream</b> (InputIterator first, InputIterator last)</td></tr>
<tr class="memitem:aa712d31b5091ed057a8127d781ba3b21"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa712d31b5091ed057a8127d781ba3b21"></a>
template&lt;typename... Lhs, typename... Rhs&gt; </td></tr>
<tr class="memitem:aa712d31b5091ed057a8127d781ba3b21"><td class="memTemplItemLeft" align="right" valign="top">match_expr&lt; Lhs..., Rhs...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator,</b> (const match_expr&lt; Lhs...&gt; &amp;lhs, const match_expr&lt; Rhs...&gt; &amp;rhs)</td></tr>
<tr class="memitem:a1e208e5b71226832e8d7ea802132b3cc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1e208e5b71226832e8d7ea802132b3cc"></a>
template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a1e208e5b71226832e8d7ea802132b3cc"><td class="memTemplItemLeft" align="right" valign="top">match_expr_from_type_list<br class="typebreak"/>
&lt; typename util::tl_concat<br class="typebreak"/>
&lt; typename Arg0::cases_list, <br class="typebreak"/>
typename Args::cases_list... &gt;<br class="typebreak"/>
::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (const Arg0 &amp;arg0, const Args &amp;...args)</td></tr>
<tr class="memitem:a9763cbc53d3d921baac7786de890d319"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9763cbc53d3d921baac7786de890d319"></a>
template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a9763cbc53d3d921baac7786de890d319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a><br class="typebreak"/>
&lt; detail::behavior_impl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_concat</b> (const Arg0 &amp;arg0, const Args &amp;...args)</td></tr>
<tr class="memitem:a9970a81e4fc1ec92f11953d29197cd5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9970a81e4fc1ec92f11953d29197cd5d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcppa_1_1message__id__t.html">message_id_t</a> &amp;lhs, const <a class="el" href="classcppa_1_1message__id__t.html">message_id_t</a> &amp;rhs)</td></tr>
<tr class="memitem:a7538f0e3be2bfe64f6b54f88896484c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7538f0e3be2bfe64f6b54f88896484c0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcppa_1_1message__id__t.html">message_id_t</a> &amp;lhs, const <a class="el" href="classcppa_1_1message__id__t.html">message_id_t</a> &amp;rhs)</td></tr>
<tr class="memitem:a9e103f83664c764b44799700daa1e83e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e103f83664c764b44799700daa1e83e"></a>
const <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>uniform_typeid</b> (const std::type_info &amp;)</td></tr>
<tr class="memitem:ac1d771014d43e74ef4e17073bebaa2ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1d771014d43e74ef4e17073bebaa2ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> &amp;lhs, const std::type_info &amp;rhs)</td></tr>
<tr class="memitem:aeccfef6633740c1eff30d983dcfba54f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeccfef6633740c1eff30d983dcfba54f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcppa_1_1object.html">object</a> &amp;lhs, const <a class="el" href="classcppa_1_1object.html">object</a> &amp;rhs)</td></tr>
<tr class="memitem:afc4d0a97a3d502f72511ea3464db9e13"><td class="memTemplParams" colspan="2"><a class="anchor" id="afc4d0a97a3d502f72511ea3464db9e13"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc4d0a97a3d502f72511ea3464db9e13"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (<a class="el" href="classcppa_1_1object.html">object</a> &amp;obj)</td></tr>
<tr class="memitem:aafac7c509fc9734cffbf3608e64a04b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="aafac7c509fc9734cffbf3608e64a04b5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafac7c509fc9734cffbf3608e64a04b5"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="classcppa_1_1object.html">object</a> &amp;obj)</td></tr>
<tr class="memitem:a18bab167555966e432564cdee1611825"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18bab167555966e432564cdee1611825"><td class="memTemplItemLeft" align="right" valign="top">___&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a18bab167555966e432564cdee1611825">val</a> ()</td></tr>
<tr class="memdesc:a18bab167555966e432564cdee1611825"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches any value of type <code>T</code>.  <a href="#a18bab167555966e432564cdee1611825"></a><br/></td></tr>
<tr class="memitem:a2f7ec3894c43620a6dea726625e3e808"><td class="memTemplParams" colspan="2">template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:a2f7ec3894c43620a6dea726625e3e808"><td class="memTemplItemLeft" align="right" valign="top">___&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a2f7ec3894c43620a6dea726625e3e808">on</a> (const Arg0 &amp;arg0, const Args &amp;...args)</td></tr>
<tr class="memdesc:a2f7ec3894c43620a6dea726625e3e808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches values.  <a href="#a2f7ec3894c43620a6dea726625e3e808"></a><br/></td></tr>
<tr class="memitem:abdf16cec61f25dc58e5b649c51ab36a5"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:abdf16cec61f25dc58e5b649c51ab36a5"><td class="memTemplItemLeft" align="right" valign="top">___&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#abdf16cec61f25dc58e5b649c51ab36a5">on</a> ()</td></tr>
<tr class="memdesc:abdf16cec61f25dc58e5b649c51ab36a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches types.  <a href="#abdf16cec61f25dc58e5b649c51ab36a5"></a><br/></td></tr>
<tr class="memitem:a623e50578009f84547699fefe8ae40f4"><td class="memTemplParams" colspan="2">template&lt;atom_value... Atoms, typename... Ts&gt; </td></tr>
<tr class="memitem:a623e50578009f84547699fefe8ae40f4"><td class="memTemplItemLeft" align="right" valign="top">___&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a623e50578009f84547699fefe8ae40f4">on</a> ()</td></tr>
<tr class="memdesc:a623e50578009f84547699fefe8ae40f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches types.  <a href="#a623e50578009f84547699fefe8ae40f4"></a><br/></td></tr>
<tr class="memitem:a78997285c975b7db83053fe800e26b6f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a78997285c975b7db83053fe800e26b6f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a78997285c975b7db83053fe800e26b6f"><td class="memTemplItemLeft" align="right" valign="top">detail::conv_arg_impl&lt; T &gt;<br class="typebreak"/>
::result_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conv_arg</b> (const std::string &amp;arg)</td></tr>
<tr class="memitem:a203490e67e091f123d0cc6f7884e88c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a203490e67e091f123d0cc6f7884e88c9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a203490e67e091f123d0cc6f7884e88c9"><td class="memTemplItemLeft" align="right" valign="top">detail::rd_arg_functor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rd_arg</b> (T &amp;storage)</td></tr>
<tr class="memitem:ab1ebc36e2bddc5cef48f1688af4d7608"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab1ebc36e2bddc5cef48f1688af4d7608"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1ebc36e2bddc5cef48f1688af4d7608"><td class="memTemplItemLeft" align="right" valign="top">detail::add_arg_functor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_arg</b> (std::vector&lt; T &gt; &amp;storage)</td></tr>
<tr class="memitem:a18d58a681b4c0cc4d75c2383bf3829a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18d58a681b4c0cc4d75c2383bf3829a8"></a>
detail::opt_rvalue_builder&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>on_opt</b> (char short_opt, std::string long_opt, options_description *desc=nullptr, std::string help_text=&quot;&quot;, std::string help_group=&quot;general options&quot;)</td></tr>
<tr class="memitem:a3fdef777679df7e29d359102e22f61a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fdef777679df7e29d359102e22f61a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>decltype</b> (<a class="el" href="namespacecppa.html#a2f7ec3894c43620a6dea726625e3e808">on</a>&lt; std::string &gt;().when(cppa::placeholders::_x1.in(std::vector&lt; std::string &gt;()))) on_vopt(char short_opt</td></tr>
<tr class="memitem:a3e9f8e43fb78f1a6c9afb6700ebe4404"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e9f8e43fb78f1a6c9afb6700ebe4404"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>print_desc</b> (options_description *desc, std::ostream &amp;out=std::cout)</td></tr>
<tr class="memitem:aeb2216fa186264747a6256d0d21dbf98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb2216fa186264747a6256d0d21dbf98"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>print_desc_and_exit</b> (options_description *desc, std::ostream &amp;out=std::cout, int exit_reason=0)</td></tr>
<tr class="memitem:a33344c46529f70febab48161c0c53a68"><td class="memTemplParams" colspan="2">template&lt;typename Types &gt; </td></tr>
<tr class="memitem:a33344c46529f70febab48161c0c53a68"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecppa.html#a5ab63f2274711ea5cce959c91d793b25">wildcard_position</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a33344c46529f70febab48161c0c53a68">get_wildcard_position</a> ()</td></tr>
<tr class="memdesc:a33344c46529f70febab48161c0c53a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of <a class="el" href="structcppa_1_1anything.html">anything</a> from the type list <code>Types</code>.  <a href="#a33344c46529f70febab48161c0c53a68"></a><br/></td></tr>
<tr class="memitem:ga5d1de7bc77d88156d0e12e373ab2c613"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga5d1de7bc77d88156d0e12e373ab2c613">primitive_type_name</a> (<a class="el" href="group___type_system.html#ga5a8afa49a3547b610d4a50b3ab1dceb6">primitive_type</a> ptype)</td></tr>
<tr class="memdesc:ga5d1de7bc77d88156d0e12e373ab2c613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a <a class="el" href="group___type_system.html#ga5a8afa49a3547b610d4a50b3ab1dceb6" title="Represents the type flag of primitive_variant.">primitive_type</a> value to its name.  <a href="group___type_system.html#ga5d1de7bc77d88156d0e12e373ab2c613"></a><br/></td></tr>
<tr class="memitem:a1f48cc1f5e2597c4a131d292145f728f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f48cc1f5e2597c4a131d292145f728f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f48cc1f5e2597c4a131d292145f728f"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a> &amp;pv)</td></tr>
<tr class="memitem:aeb7eeed8ed3edc2558cf01f26bf86691"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeb7eeed8ed3edc2558cf01f26bf86691"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb7eeed8ed3edc2558cf01f26bf86691"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (<a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a> &amp;pv)</td></tr>
<tr class="memitem:a00ad36edc791ad88439e6b1d30e9ea14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00ad36edc791ad88439e6b1d30e9ea14"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>node_id_from_string</b> (const std::string &amp;hash, <a class="el" href="classcppa_1_1process__information.html#ab9a871d7dff99b789b7b44cb67480d9d">process_information::node_id_type</a> &amp;node_id)</td></tr>
<tr class="memitem:a6da650abe0612dd640f67af532373440"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6da650abe0612dd640f67af532373440"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal</b> (const std::string &amp;hash, const <a class="el" href="classcppa_1_1process__information.html#ab9a871d7dff99b789b7b44cb67480d9d">process_information::node_id_type</a> &amp;node_id)</td></tr>
<tr class="memitem:a9fadf880997152157b01eb708534fe09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fadf880997152157b01eb708534fe09"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal</b> (const <a class="el" href="classcppa_1_1process__information.html#ab9a871d7dff99b789b7b44cb67480d9d">process_information::node_id_type</a> &amp;node_id, const std::string &amp;hash)</td></tr>
<tr class="memitem:a671f171f6353ab9c5c859842a242faab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a671f171f6353ab9c5c859842a242faab">receive</a> (<a class="el" href="classcppa_1_1behavior.html">behavior</a> &amp;bhvr)</td></tr>
<tr class="memdesc:a671f171f6353ab9c5c859842a242faab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues the next message from the mailbox that's matched by <code>bhvr</code> and executes the corresponding callback.  <a href="#a671f171f6353ab9c5c859842a242faab"></a><br/></td></tr>
<tr class="memitem:a779def4c306e2d63d1cd74fe2d9d7cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a779def4c306e2d63d1cd74fe2d9d7cb1">receive_loop</a> (<a class="el" href="classcppa_1_1behavior.html">behavior</a> &amp;bhvr)</td></tr>
<tr class="memdesc:a779def4c306e2d63d1cd74fe2d9d7cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives messages in an endless loop.  <a href="#a779def4c306e2d63d1cd74fe2d9d7cb1"></a><br/></td></tr>
<tr class="memitem:af50e3deafdaddd7159f915841e7fe24c"><td class="memTemplParams" colspan="2">template&lt;typename Statement &gt; </td></tr>
<tr class="memitem:af50e3deafdaddd7159f915841e7fe24c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#af50e3deafdaddd7159f915841e7fe24c">receive_while</a> (Statement &amp;&amp;stmt)</td></tr>
<tr class="memdesc:af50e3deafdaddd7159f915841e7fe24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives messages as long as <code>stmt</code> returns true.  <a href="#af50e3deafdaddd7159f915841e7fe24c"></a><br/></td></tr>
<tr class="memitem:ae06258ccd73463e833ade58a29406e66"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae06258ccd73463e833ade58a29406e66"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ae06258ccd73463e833ade58a29406e66">receive_for</a> (T &amp;begin, const T &amp;end)</td></tr>
<tr class="memdesc:ae06258ccd73463e833ade58a29406e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives messages as in a range-based loop.  <a href="#ae06258ccd73463e833ade58a29406e66"></a><br/></td></tr>
<tr class="memitem:ab32fd2e5649ee811c08a9ff74e9bed84"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ab32fd2e5649ee811c08a9ff74e9bed84">do_receive</a> (<a class="el" href="classcppa_1_1behavior.html">behavior</a> &amp;bhvr)</td></tr>
<tr class="memdesc:ab32fd2e5649ee811c08a9ff74e9bed84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives messages until <code>stmt</code> returns true.  <a href="#ab32fd2e5649ee811c08a9ff74e9bed84"></a><br/></td></tr>
<tr class="memitem:a9fd959a7ff3c017ded6b64ee72dcec97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9fd959a7ff3c017ded6b64ee72dcec97">set_scheduler</a> (scheduler *sched)</td></tr>
<tr class="memdesc:a9fd959a7ff3c017ded6b64ee72dcec97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scheduler to <code>sched</code>.  <a href="#a9fd959a7ff3c017ded6b64ee72dcec97"></a><br/></td></tr>
<tr class="memitem:a438040c204e8dc7819cd7ca9bd661eec"><td class="memItemLeft" align="right" valign="top">scheduler *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a438040c204e8dc7819cd7ca9bd661eec">get_scheduler</a> ()</td></tr>
<tr class="memdesc:a438040c204e8dc7819cd7ca9bd661eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the actual used scheduler implementation.  <a href="#a438040c204e8dc7819cd7ca9bd661eec"></a><br/></td></tr>
<tr class="memitem:a58a28e93004ce87aa330248e4a5604ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58a28e93004ce87aa330248e4a5604ec"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> &amp;what)</td></tr>
<tr class="memitem:a19081cbea5505274ae14eebc52c1ea49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19081cbea5505274ae14eebc52c1ea49"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1network_1_1addressed__message.html">network::addressed_message</a> &amp;what)</td></tr>
<tr class="memitem:ab5dafe56a214fb056845a07e3b884ca7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5dafe56a214fb056845a07e3b884ca7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> &amp;what)</td></tr>
<tr class="memitem:afb103c782d4dd432e52f51e247743c3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb103c782d4dd432e52f51e247743c3f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1process__information.html">process_information</a> &amp;what)</td></tr>
<tr class="memitem:a7919488dad32bd35a6e461f4ae6d0bd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7919488dad32bd35a6e461f4ae6d0bd7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1object.html">object</a> &amp;what)</td></tr>
<tr class="memitem:a60aae38fbd2f412089646134bbb5c75f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60aae38fbd2f412089646134bbb5c75f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a60aae38fbd2f412089646134bbb5c75f">to_verbose_string</a> (const std::exception &amp;e)</td></tr>
<tr class="memdesc:a60aae38fbd2f412089646134bbb5c75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>e</code> to a string including the demangled type of e and <code>e.what()</code>. <br/></td></tr>
<tr class="memitem:ac9456f6c3944e9f8f47ec8fc678d99d5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac9456f6c3944e9f8f47ec8fc678d99d5"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:ac9456f6c3944e9f8f47ec8fc678d99d5"><td class="memTemplItemLeft" align="right" valign="top">util::at&lt; N, Ts...&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const util::type_list&lt; Ts...&gt; &amp;)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga3ae2b7f14f29131233296643035e5128"><td class="memTemplParams" colspan="2">template&lt;class C , typename... Args&gt; </td></tr>
<tr class="memitem:ga3ae2b7f14f29131233296643035e5128"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_base_of&lt; <a class="el" href="classcppa_1_1channel.html">channel</a>, C &gt;<br class="typebreak"/>
::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga3ae2b7f14f29131233296643035e5128">send_tuple</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; C &gt; &amp;whom, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:ga3ae2b7f14f29131233296643035e5128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>what</code> as a message to <code>whom</code>.  <a href="group___message_handling.html#ga3ae2b7f14f29131233296643035e5128"></a><br/></td></tr>
<tr class="memitem:ga3d831d687613a6a5ebc143b7e347858b"><td class="memTemplParams" colspan="2">template&lt;class C , typename... Args&gt; </td></tr>
<tr class="memitem:ga3d831d687613a6a5ebc143b7e347858b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_base_of&lt; <a class="el" href="classcppa_1_1channel.html">channel</a>, C &gt;<br class="typebreak"/>
::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga3d831d687613a6a5ebc143b7e347858b">send</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; C &gt; &amp;whom, Args &amp;&amp;...what)</td></tr>
<tr class="memdesc:ga3d831d687613a6a5ebc143b7e347858b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>{what...}</code> as a message to <code>whom</code>.  <a href="group___message_handling.html#ga3d831d687613a6a5ebc143b7e347858b"></a><br/></td></tr>
<tr class="memitem:gac75843b3cdee57feeb6844a5568e4bfa"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:gac75843b3cdee57feeb6844a5568e4bfa"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; std::is_base_of&lt; <a class="el" href="classcppa_1_1channel.html">channel</a>, C &gt;<br class="typebreak"/>
::value, const <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a><br class="typebreak"/>
&lt; C &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#gac75843b3cdee57feeb6844a5568e4bfa">operator&lt;&lt;</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; C &gt; &amp;whom, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:gac75843b3cdee57feeb6844a5568e4bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to <code>whom</code>.  <a href="group___message_handling.html#gac75843b3cdee57feeb6844a5568e4bfa"></a><br/></td></tr>
<tr class="memitem:ga5067369f214ff6f8581b87b9c730ed30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1message__future.html">message_future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga5067369f214ff6f8581b87b9c730ed30">sync_send_tuple</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> &amp;whom, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:ga5067369f214ff6f8581b87b9c730ed30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>what</code> as a synchronous message to <code>whom</code>.  <a href="group___message_handling.html#ga5067369f214ff6f8581b87b9c730ed30"></a><br/></td></tr>
<tr class="memitem:ga48f4fbdf4bb8d1d262bec9eeb6d053c9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga48f4fbdf4bb8d1d262bec9eeb6d053c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1message__future.html">message_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga48f4fbdf4bb8d1d262bec9eeb6d053c9">sync_send</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> &amp;whom, Args &amp;&amp;...what)</td></tr>
<tr class="memdesc:ga48f4fbdf4bb8d1d262bec9eeb6d053c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>{what...}</code> as a synchronous message to <code>whom</code>.  <a href="group___message_handling.html#ga48f4fbdf4bb8d1d262bec9eeb6d053c9"></a><br/></td></tr>
<tr class="memitem:ga84570199b65a462b1acf37e1428dcc16"><td class="memItemLeft" align="right" valign="top">sync_recv_helper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga84570199b65a462b1acf37e1428dcc16">receive_response</a> (const <a class="el" href="classcppa_1_1message__future.html">message_future</a> &amp;handle)</td></tr>
<tr class="memdesc:ga84570199b65a462b1acf37e1428dcc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles a synchronous response message in an event-based way.  <a href="group___message_handling.html#ga84570199b65a462b1acf37e1428dcc16"></a><br/></td></tr>
<tr class="memitem:ga4d847736b07a78186a20cd2b25e7fa47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga4d847736b07a78186a20cd2b25e7fa47">reply_tuple</a> (<a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:ga4d847736b07a78186a20cd2b25e7fa47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to the sender of the last received message.  <a href="group___message_handling.html#ga4d847736b07a78186a20cd2b25e7fa47"></a><br/></td></tr>
<tr class="memitem:gac8769898500320bfc51235a5fe771b11"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gac8769898500320bfc51235a5fe771b11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#gac8769898500320bfc51235a5fe771b11">reply</a> (Args &amp;&amp;...what)</td></tr>
<tr class="memdesc:gac8769898500320bfc51235a5fe771b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to the sender of the last received message.  <a href="group___message_handling.html#gac8769898500320bfc51235a5fe771b11"></a><br/></td></tr>
<tr class="memitem:ga9e7296666267daedec965b147f9aa1e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9e7296666267daedec965b147f9aa1e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>forward_to</b> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> &amp;whom)</td></tr>
<tr class="memitem:ga9c243f8d541dc374ba38c0792285531b"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period , typename... Args&gt; </td></tr>
<tr class="memitem:ga9c243f8d541dc374ba38c0792285531b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga9c243f8d541dc374ba38c0792285531b">delayed_send_tuple</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">channel_ptr</a> &amp;whom, const std::chrono::duration&lt; Rep, Period &gt; &amp;rtime, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:ga9c243f8d541dc374ba38c0792285531b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to <code>whom</code> that is delayed by <code>rel_time</code>.  <a href="group___message_handling.html#ga9c243f8d541dc374ba38c0792285531b"></a><br/></td></tr>
<tr class="memitem:ga779e91c3e3bda10ad356004de80abc86"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period , typename... Args&gt; </td></tr>
<tr class="memitem:ga779e91c3e3bda10ad356004de80abc86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga779e91c3e3bda10ad356004de80abc86">delayed_send</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">channel_ptr</a> &amp;whom, const std::chrono::duration&lt; Rep, Period &gt; &amp;rtime, Args &amp;&amp;...what)</td></tr>
<tr class="memdesc:ga779e91c3e3bda10ad356004de80abc86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to <code>whom</code> that is delayed by <code>rel_time</code>.  <a href="group___message_handling.html#ga779e91c3e3bda10ad356004de80abc86"></a><br/></td></tr>
<tr class="memitem:ga9406a01669ed4787cefb44f7dac0e101"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period , typename... Args&gt; </td></tr>
<tr class="memitem:ga9406a01669ed4787cefb44f7dac0e101"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga9406a01669ed4787cefb44f7dac0e101">delayed_reply_tuple</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;rtime, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:ga9406a01669ed4787cefb44f7dac0e101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a reply message that is delayed by <code>rel_time</code>.  <a href="group___message_handling.html#ga9406a01669ed4787cefb44f7dac0e101"></a><br/></td></tr>
<tr class="memitem:ga6602d51b68565e23211ae034d7b00b06"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period , typename... Args&gt; </td></tr>
<tr class="memitem:ga6602d51b68565e23211ae034d7b00b06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga6602d51b68565e23211ae034d7b00b06">delayed_reply</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;rtime, Args &amp;&amp;...what)</td></tr>
<tr class="memdesc:ga6602d51b68565e23211ae034d7b00b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a reply message that is delayed by <code>rel_time</code>.  <a href="group___message_handling.html#ga6602d51b68565e23211ae034d7b00b06"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga6dfaa32fe8444afd935a2810672c704a"><td class="memTemplParams" colspan="2">template&lt;scheduling_hint Hint, typename Fun , typename... Args&gt; </td></tr>
<tr class="memitem:ga6dfaa32fe8444afd935a2810672c704a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#ga6dfaa32fe8444afd935a2810672c704a">spawn</a> (Fun &amp;&amp;fun, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga6dfaa32fe8444afd935a2810672c704a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new context-switching or thread-mapped <a class="el" href="classcppa_1_1actor.html">actor</a> that executes <code>fun(args...)</code>.  <a href="group___actor_creation.html#ga6dfaa32fe8444afd935a2810672c704a"></a><br/></td></tr>
<tr class="memitem:gad1993d81268448dca0fdbba3d5e63e5e"><td class="memTemplParams" colspan="2">template&lt;typename Fun , typename... Args&gt; </td></tr>
<tr class="memitem:gad1993d81268448dca0fdbba3d5e63e5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gad1993d81268448dca0fdbba3d5e63e5e">spawn</a> (Fun &amp;&amp;fun, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:gad1993d81268448dca0fdbba3d5e63e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new context-switching <a class="el" href="classcppa_1_1actor.html">actor</a> that executes <code>fun(args...)</code>.  <a href="group___actor_creation.html#gad1993d81268448dca0fdbba3d5e63e5e"></a><br/></td></tr>
<tr class="memitem:ga4fa40915e311247aaa5fd5e4f7f05994"><td class="memTemplParams" colspan="2">template&lt;scheduling_hint Hint, typename Fun , typename... Args&gt; </td></tr>
<tr class="memitem:ga4fa40915e311247aaa5fd5e4f7f05994"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#ga4fa40915e311247aaa5fd5e4f7f05994">spawn_in_group</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">group_ptr</a> &amp;grp, Fun &amp;&amp;fun, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga4fa40915e311247aaa5fd5e4f7f05994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new context-switching or thread-mapped <a class="el" href="classcppa_1_1actor.html">actor</a> that executes <code>fun(args...)</code> and joins <code>grp</code> immediately.  <a href="group___actor_creation.html#ga4fa40915e311247aaa5fd5e4f7f05994"></a><br/></td></tr>
<tr class="memitem:ga6e054e5361a4a35e8a39d5144639ccd1"><td class="memTemplParams" colspan="2">template&lt;typename Fun , typename... Args&gt; </td></tr>
<tr class="memitem:ga6e054e5361a4a35e8a39d5144639ccd1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#ga6e054e5361a4a35e8a39d5144639ccd1">spawn_in_group</a> (Fun &amp;&amp;fun, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga6e054e5361a4a35e8a39d5144639ccd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new context-switching <a class="el" href="classcppa_1_1actor.html">actor</a> that executes <code>fun(args...)</code> and joins <code>grp</code> immediately.  <a href="group___actor_creation.html#ga6e054e5361a4a35e8a39d5144639ccd1"></a><br/></td></tr>
<tr class="memitem:gae9db68cd073839b4e21e0f21a93524c2"><td class="memTemplParams" colspan="2">template&lt;class ActorImpl , typename... Args&gt; </td></tr>
<tr class="memitem:gae9db68cd073839b4e21e0f21a93524c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gae9db68cd073839b4e21e0f21a93524c2">spawn</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:gae9db68cd073839b4e21e0f21a93524c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns an actor of type <code>ActorImpl</code>.  <a href="group___actor_creation.html#gae9db68cd073839b4e21e0f21a93524c2"></a><br/></td></tr>
<tr class="memitem:gaeea1cdccd0a64c12de45dfe9eb2c7e1f"><td class="memTemplParams" colspan="2">template&lt;class ActorImpl , typename... Args&gt; </td></tr>
<tr class="memitem:gaeea1cdccd0a64c12de45dfe9eb2c7e1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gaeea1cdccd0a64c12de45dfe9eb2c7e1f">spawn_in_group</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">group_ptr</a> &amp;grp, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:gaeea1cdccd0a64c12de45dfe9eb2c7e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns an actor of type <code>ActorImpl</code> that joins <code>grp</code> immediately.  <a href="group___actor_creation.html#gaeea1cdccd0a64c12de45dfe9eb2c7e1f"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3766bb0805c4b771f1b41d77f3f7a946"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3766bb0805c4b771f1b41d77f3f7a946"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_socket</b> = -1</td></tr>
<tr class="memitem:a2bb69070836525b04fcc9f057221de31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bb69070836525b04fcc9f057221de31"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>First</b></td></tr>
<tr class="memitem:ad2153adcbc3070cb1d1b9aec94fef729"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2153adcbc3070cb1d1b9aec94fef729"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>Second</b></td></tr>
<tr class="memitem:a8b4879d9cdef5c6c0995b30ee37d935e"><td class="memItemLeft" align="right" valign="top">constexpr ___&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a8b4879d9cdef5c6c0995b30ee37d935e">arg_match</a></td></tr>
<tr class="memdesc:a8b4879d9cdef5c6c0995b30ee37d935e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches the argument types of a given callback. Must be the last argument to <a class="el" href="namespacecppa.html#a2f7ec3894c43620a6dea726625e3e808">on()</a>.  <a href="#a8b4879d9cdef5c6c0995b30ee37d935e"></a><br/></td></tr>
<tr class="memitem:a1845e56c3aad8758b11698353f7317c5"><td class="memItemLeft" align="right" valign="top">constexpr ___&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a1845e56c3aad8758b11698353f7317c5">on_arg_match</a></td></tr>
<tr class="memdesc:a1845e56c3aad8758b11698353f7317c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression.  <a href="#a1845e56c3aad8758b11698353f7317c5"></a><br/></td></tr>
<tr class="memitem:a6fd601df8b1aff0ef276f80a103c5f4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fd601df8b1aff0ef276f80a103c5f4e"></a>
constexpr <a class="el" href="structcppa_1_1anything.html">anything</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a6fd601df8b1aff0ef276f80a103c5f4e">any_vals</a></td></tr>
<tr class="memdesc:a6fd601df8b1aff0ef276f80a103c5f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches any number of any values. <br/></td></tr>
<tr class="memitem:a3ad5b68eab4045e02909b9a2bc707aa7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ad5b68eab4045e02909b9a2bc707aa7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>long_opt</b></td></tr>
<tr class="memitem:a3eb178de20ce9e22a81a025959730466"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eb178de20ce9e22a81a025959730466"></a>
std::string options_description *&#160;</td><td class="memItemRight" valign="bottom"><b>desc</b> = nullptr</td></tr>
<tr class="memitem:a89119412ea3bacad7cadb8156a0442b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89119412ea3bacad7cadb8156a0442b9"></a>
std::string <br class="typebreak"/>
options_description <br class="typebreak"/>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>help_text</b> = &quot;&quot;</td></tr>
<tr class="memitem:a842fbee51407c9e40b79e9aba7a53dc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a842fbee51407c9e40b79e9aba7a53dc4"></a>
std::string <br class="typebreak"/>
options_description <br class="typebreak"/>
std::string std::string&#160;</td><td class="memItemRight" valign="bottom"><b>help_group</b> = &quot;general options&quot;)</td></tr>
<tr class="memitem:a241a516282529c45499a49101c35aa74"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>primitive_type_names</b> []</td></tr>
<tr class="memitem:abdc77f5b27edd9e40908860db20e666d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdc77f5b27edd9e40908860db20e666d"></a>
<a class="el" href="classcppa_1_1local__actor.html">local_actor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#abdc77f5b27edd9e40908860db20e666d">self</a></td></tr>
<tr class="memdesc:abdc77f5b27edd9e40908860db20e666d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always points to the current actor. Similar to <code>this</code> in an object-oriented context. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Root namespace of libcppa. </p>
</div><hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ada43001c9a9dd2cbb1f87656b7fa1cb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacecppa.html#ada43001c9a9dd2cbb1f87656b7fa1cb4">cppa::scheduling_hint</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Denotes whether a user wants an actor to take part in cooperative scheduling or not. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ada43001c9a9dd2cbb1f87656b7fa1cb4aceac3de2f38c06f50912d1870df54d55"></a>scheduled</em>&nbsp;</td><td>
<p>Indicates that an actor takes part in cooperative scheduling. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ada43001c9a9dd2cbb1f87656b7fa1cb4aa095bad54a9491227ae34ec4e8036eed"></a>detached</em>&nbsp;</td><td>
<p>Indicates that an actor should run in its own thread. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ada43001c9a9dd2cbb1f87656b7fa1cb4a855c80d325a3d15c95b310a3a4f7528c"></a>detached_and_hidden</em>&nbsp;</td><td>
<p>Indicates that an actor should run in its own thread, but it is ignored by <a class="el" href="">await_others_done()</a>. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ada43001c9a9dd2cbb1f87656b7fa1cb4ac5633e6e80b07bfbea04d091909ab35e"></a>scheduled_and_hidden</em>&nbsp;</td><td>
<p>Indicates that an actor takes part in cooperative scheduling, but it is ignored by <a class="el" href="">await_others_done()</a>. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a9ed5b5aa07c384b14899beae80974d47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacecppa.html#a5dd69804058d7adaef774fd953c63b97">atom_value</a> cppa::atom </td>
          <td>(</td>
          <td class="paramtype">char const (&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[Size]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an atom from given string literal. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String constant representing an atom. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A compact representation of <code>str</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a1">dancing_kirby.cpp</a>, <a class="el" href="dining_philosophers_8cpp-example.html#a4">dining_philosophers.cpp</a>, and <a class="el" href="math_actor_example_8cpp-example.html#a2">math_actor_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a185090573ffb146384ccdfa94172c23e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::await_all_others_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks execution of this actor until all other actors finished execution. </p>
<dl class="section warning"><dt>Warning:</dt><dd>This function will cause a deadlock if called from multiple actors. </dd>
<dd>
Do not call this function in cooperatively scheduled actors. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dining_philosophers_8cpp-example.html#a8">dining_philosophers.cpp</a>, <a class="el" href="hello_world_example_8cpp-example.html#a4">hello_world_example.cpp</a>, and <a class="el" href="math_actor_example_8cpp-example.html#a12">math_actor_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ab32fd2e5649ee811c08a9ff74e9bed84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto cppa::do_receive </td>
          <td>(</td>
          <td class="paramtype">behavior &amp;&#160;</td>
          <td class="paramname"><em>bhvr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives messages until <code>stmt</code> returns true. </p>
<p>Semantically equal to: <code>do { receive(...); } while (stmt() == false);</code></p>
<p><b>Usage example:</b> </p>
<div class="fragment"><div class="line">   <span class="keywordtype">int</span> i = 0;</div>
<div class="line">   <a class="code" href="namespacecppa.html#ab32fd2e5649ee811c08a9ff74e9bed84" title="Receives messages until stmt returns true.">do_receive</a></div>
<div class="line">   (</div>
<div class="line">       on&lt;int&gt;() &gt;&gt; int_fun,</div>
<div class="line">       on&lt;float&gt;() &gt;&gt; float_fun</div>
<div class="line">   )</div>
<div class="line">   .until([&amp;]() { <span class="keywordflow">return</span> (++i &gt;= 10); };</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">bhvr</td><td>Denotes the actor's response the next incoming message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A functor providing the <code>until</code> member function. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="math_actor_example_8cpp-example.html#a0">math_actor_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="aaa221547ef879ba5b42f7cc7820f90e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T cppa::from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string created by <a class="el" href="namespacecppa.html#a76a9f2873d0e97eb7ceffb6101e8e507">to_string</a> to its original value. </p>
<p>Convenience function that deserializes a value from <code>what</code> and converts the result to <code>T</code>.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>String representation of a serialized value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>An <a class="el" href="classcppa_1_1object.html">object</a> instance that contains the deserialized value.</dd></dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the result is not of type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The deserialized value as instance of <code>T</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a438040c204e8dc7819cd7ca9bd661eec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scheduler* cppa::get_scheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the actual used scheduler implementation. </p>
<dl class="section return"><dt>Returns:</dt><dd>The active scheduler (usually default constructed). </dd></dl>

</div>
</div>
<a class="anchor" id="a33344c46529f70febab48161c0c53a68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Types &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacecppa.html#a5ab63f2274711ea5cce959c91d793b25">wildcard_position</a> cppa::get_wildcard_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the position of <a class="el" href="structcppa_1_1anything.html">anything</a> from the type list <code>Types</code>. </p>
<dl class="tparams"><dt>Template Parameters:</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>template parameter pack as <a class="el" href="">type_list</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d0ed8b8c047b52ff833c8315b1bf963"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> cppa::make_any_tuple </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> containing the elements <code>args</code>. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Values to initialize the tuple elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad65859efc090932630d14b226b9c9624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">detail::match_helper cppa::match </td>
          <td>(</td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Tuple or value that should be matched against a pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="adaa18a8117e9022caea2b0606c11ebbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::match_helper cppa::match </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression.  </p>
<p><dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Tuple or value that should be matched against a pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="a190b08703616bd22402836fcb24033a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cppa::match_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression that matches each element in range [first, last). </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element (excluded). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="abd625f5c7c3705bb7c951c425ce96469"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename Projection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cppa::match_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Projection&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression that matches <code>proj(i)</code> for each element <code>i</code> in range [first, last). </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element (excluded). </td></tr>
    <tr><td class="paramname">proj</td><td>Projection or extractor functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f7ec3894c43620a6dea726625e3e808"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg0 , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">___ cppa::on </td>
          <td>(</td>
          <td class="paramtype">const Arg0 &amp;&#160;</td>
          <td class="paramname"><em>arg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches values. </p>
<p>This overload can be used with the wildcards <a class="el" href="namespacecppa.html#a18bab167555966e432564cdee1611825">val</a>, <a class="el" href="namespacecppa.html#a6fd601df8b1aff0ef276f80a103c5f4e">any_vals</a> and <a class="el" href="namespacecppa.html#a8b4879d9cdef5c6c0995b30ee37d935e">arg_match</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a3">dancing_kirby.cpp</a>, <a class="el" href="dining_philosophers_8cpp-example.html#a3">dining_philosophers.cpp</a>, and <a class="el" href="math_actor_example_8cpp-example.html#a1">math_actor_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="abdf16cec61f25dc58e5b649c51ab36a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">___ cppa::on </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches types. </p>
<p>This overload matches types only. The type <a class="el" href="structcppa_1_1anything.html">anything</a> can be used as wildcard to match any number of elements of any types. </p>

</div>
</div>
<a class="anchor" id="a623e50578009f84547699fefe8ae40f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atom_value... Atoms, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">___ cppa::on </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches types. </p>
<p>This overload matches up to four leading atoms. The type <a class="el" href="structcppa_1_1anything.html">anything</a> can be used as wildcard to match any number of elements of any types. </p>

</div>
</div>
<a class="anchor" id="a487e6c08f5f4f7de4775418547f7e93e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppa_1_1actor.html#a15b74113cbde6221df8f00c25b6c2a56">actor_ptr</a>&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publishes <code>whom</code> at <code>port</code>. </p>
<p>The connection is automatically closed if the lifetime of <code>whom</code> ends. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Actor that should be published at <code>port</code>. </td></tr>
    <tr><td class="paramname">port</td><td>Unused TCP port. </td></tr>
    <tr><td class="paramname">addr</td><td>The IP address to listen to, or <code>INADDR_ANY</code> if <code>addr</code> is <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcppa_1_1bind__failure.html" title="Thrown to indicate that an actor publishing failed because the requested port could not be used...">bind_failure</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9c73df0929df9b069096d3d9f9499bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppa_1_1actor.html#a15b74113cbde6221df8f00c25b6c2a56">actor_ptr</a>&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; network::acceptor &gt;&#160;</td>
          <td class="paramname"><em>acceptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publishes <code>whom</code> using <code>acceptor</code> to handle incoming connections. </p>
<p>The connection is automatically closed if the lifetime of <code>whom</code> ends. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Actor that should be published at <code>port</code>. </td></tr>
    <tr><td class="paramname">acceptor</td><td>Network technology-specific acceptor implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae213a56201820111919afe92aa287586"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::publish_local_groups_at </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes <em>all</em> local groups accessible via network on address <code>addr</code> and <code>port</code>. </p>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcppa_1_1bind__failure.html" title="Thrown to indicate that an actor publishing failed because the requested port could not be used...">bind_failure</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classcppa_1_1network__error.html" title="Thrown to indicate that either an actor publishing failed or libcppa was unable to connect to a remot...">network_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a671f171f6353ab9c5c859842a242faab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::receive </td>
          <td>(</td>
          <td class="paramtype">behavior &amp;&#160;</td>
          <td class="paramname"><em>bhvr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dequeues the next message from the mailbox that's matched by <code>bhvr</code> and executes the corresponding callback. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">bhvr</td><td>Denotes the actor's response the next incoming message. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_example_2_8cpp-example.html#a2">announce_example_2.cpp</a>, <a class="el" href="announce_example_3_8cpp-example.html#a2">announce_example_3.cpp</a>, <a class="el" href="hello_world_example_8cpp-example.html#a0">hello_world_example.cpp</a>, and <a class="el" href="math_actor_example_8cpp-example.html#a9">math_actor_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae06258ccd73463e833ade58a29406e66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cppa::receive_for </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives messages as in a range-based loop. </p>
<p>Semantically equal to: <code>for ( ; begin != end; ++begin) { receive(...); }</code>.</p>
<p><b>Usage example:</b> </p>
<div class="fragment"><div class="line">   <span class="keywordtype">int</span> i = 0;</div>
<div class="line">   <a class="code" href="namespacecppa.html#ae06258ccd73463e833ade58a29406e66" title="Receives messages as in a range-based loop.">receive_for</a>(i, 10)</div>
<div class="line">   (</div>
<div class="line">       <a class="code" href="namespacecppa.html#a2f7ec3894c43620a6dea726625e3e808" title="Left-hand side of a partial function expression that matches values.">on</a>(<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;get&quot;</span>)) &gt;&gt; [&amp;]() { <a class="code" href="group___message_handling.html#gac8769898500320bfc51235a5fe771b11" title="Sends a message to the sender of the last received message.">reply</a>(<span class="stringliteral">&quot;result&quot;</span>, i); }</div>
<div class="line">   );</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>First value in range. </td></tr>
    <tr><td class="paramname">end</td><td>Last value in range (excluded). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A functor implementing the loop. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_example_4_8cpp-example.html#a3">announce_example_4.cpp</a>, <a class="el" href="announce_example_5_8cpp-example.html#a16">announce_example_5.cpp</a>, and <a class="el" href="dancing_kirby_8cpp-example.html#a2">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a779def4c306e2d63d1cd74fe2d9d7cb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::receive_loop </td>
          <td>(</td>
          <td class="paramtype">behavior &amp;&#160;</td>
          <td class="paramname"><em>bhvr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives messages in an endless loop. </p>
<p>Semantically equal to: <code>for (;;) { receive(bhvr); }</code> </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">bhvr</td><td>Denotes the actor's response the next incoming message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af50e3deafdaddd7159f915841e7fe24c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Statement &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cppa::receive_while </td>
          <td>(</td>
          <td class="paramtype">Statement &amp;&amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives messages as long as <code>stmt</code> returns true. </p>
<p>Semantically equal to: <code>while (stmt()) { receive(...); }</code>.</p>
<p><b>Usage example:</b> </p>
<div class="fragment"><div class="line">   <span class="keywordtype">int</span> i = 0;</div>
<div class="line">   <a class="code" href="namespacecppa.html#af50e3deafdaddd7159f915841e7fe24c" title="Receives messages as long as stmt returns true.">receive_while</a>([&amp;]() { <span class="keywordflow">return</span> (++i &lt;= 10); })</div>
<div class="line">   (</div>
<div class="line">       on&lt;int&gt;() &gt;&gt; int_fun,</div>
<div class="line">       on&lt;float&gt;() &gt;&gt; float_fun</div>
<div class="line">   );</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>Lambda expression, functor or function returning a <code>bool</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>A functor implementing the loop. </dd></dl>

</div>
</div>
<a class="anchor" id="a76739f7f372b92999ee9b80d332093bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::remote_actor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to the actor at <code>host</code> on given <code>port</code>. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Valid hostname or IP address. </td></tr>
    <tr><td class="paramname">port</td><td>TCP port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e44ab5ef88ac98dd909f3a09bbf181d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::remote_actor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to the actor at <code>host</code> on given <code>port</code>.  </p>
<p><dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Valid hostname or IP address. </td></tr>
    <tr><td class="paramname">port</td><td>TCP port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>
 </p>

</div>
</div>
<a class="anchor" id="aa39f7d863455eec31681ebd1879e4fd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::remote_actor </td>
          <td>(</td>
          <td class="paramtype">network::io_stream_ptr_pair&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to the actor via given <code>connection</code>. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">connection</td><td>A connection to another libcppa process described by a pair of input and output stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fd959a7ff3c017ded6b64ee72dcec97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::set_scheduler </td>
          <td>(</td>
          <td class="paramtype">scheduler *&#160;</td>
          <td class="paramname"><em>sched</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the scheduler to <code>sched</code>. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched</td><td>A user-defined scheduler implementation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition:</dt><dd><code>sched != nullptr</code>. </dd></dl>
<dl class="exception"><dt>Exceptions:</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there's already a scheduler defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76a9f2873d0e97eb7ceffb6101e8e507"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cppa::to_string </td>
          <td>(</td>
          <td class="paramtype">const atom_value &amp;&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>what</code> as a string representation. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Compact representation of an atom. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd><code>what</code> as string. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_example_4_8cpp-example.html#a4">announce_example_4.cpp</a>, <a class="el" href="announce_example_5_8cpp-example.html#a17">announce_example_5.cpp</a>, and <a class="el" href="math_actor_example_8cpp-example.html#a10">math_actor_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a18bab167555966e432564cdee1611825"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">___ cppa::val </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wildcard that matches any value of type <code>T</code>. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="math_actor_example_8cpp-example.html">Math Actor Example</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_example_2_8cpp-example.html#a0">announce_example_2.cpp</a>, <a class="el" href="announce_example_3_8cpp-example.html#a0">announce_example_3.cpp</a>, and <a class="el" href="announce_example_4_8cpp-example.html#a0">announce_example_4.cpp</a>.</dd>
</dl>
</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a8b4879d9cdef5c6c0995b30ee37d935e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ___ cppa::arg_match</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wildcard that matches the argument types of a given callback. Must be the last argument to <a class="el" href="namespacecppa.html#a2f7ec3894c43620a6dea726625e3e808">on()</a>. </p>
<dl class="section see"><dt>See also:</dt><dd><a class="el" href="math_actor_example_8cpp-example.html">Math Actor Example</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="math_actor_example_8cpp-example.html#a3">math_actor_example.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1845e56c3aad8758b11698353f7317c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ___ cppa::on_arg_match</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression. </p>
<p>Equal to <code>on(arg_match)</code>. </p>

</div>
</div>
<a class="anchor" id="a241a516282529c45499a49101c35aa74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* cppa::primitive_type_names[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"> {</div>
<div class="line">    <span class="stringliteral">&quot;pt_int8&quot;</span>,        <span class="stringliteral">&quot;pt_int16&quot;</span>,       <span class="stringliteral">&quot;pt_int32&quot;</span>,       <span class="stringliteral">&quot;pt_int64&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_uint8&quot;</span>,       <span class="stringliteral">&quot;pt_uint16&quot;</span>,      <span class="stringliteral">&quot;pt_uint32&quot;</span>,      <span class="stringliteral">&quot;pt_uint64&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_float&quot;</span>,       <span class="stringliteral">&quot;pt_double&quot;</span>,      <span class="stringliteral">&quot;pt_long_double&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_u8string&quot;</span>,    <span class="stringliteral">&quot;pt_u16string&quot;</span>,   <span class="stringliteral">&quot;pt_u32string&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_null&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Oct 27 2012 00:47:42 for libcppa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.1
</small></address>
</body>
</html>
