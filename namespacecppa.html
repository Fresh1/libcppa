<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>libcppa: cppa Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libcppa
   &#160;<span id="projectnumber">Version 0.7.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cppa Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Root namespace of libcppa.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecppa_1_1exit__reason"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1exit__reason.html">exit_reason</a></td></tr>
<tr class="memdesc:namespacecppa_1_1exit__reason"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all predefined exit reasons. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1factory"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1factory.html">factory</a></td></tr>
<tr class="memdesc:namespacecppa_1_1factory"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains factory functions to create actors from lambdas or other functors. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1intrusive"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1intrusive.html">intrusive</a></td></tr>
<tr class="memdesc:namespacecppa_1_1intrusive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains intrusive container implementations. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1network"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1network.html">network</a></td></tr>
<tr class="memdesc:namespacecppa_1_1network"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all network related classes. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1opencl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1opencl.html">opencl</a></td></tr>
<tr class="memdesc:namespacecppa_1_1opencl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all classes of libcppa's OpenCL binding (optional). <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1placeholders"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1placeholders.html">placeholders</a></td></tr>
<tr class="memdesc:namespacecppa_1_1placeholders"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the guard placeholders <code>_x1</code> to <code>_x9</code>. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecppa_1_1util"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa_1_1util.html">util</a></td></tr>
<tr class="memdesc:namespacecppa_1_1util"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains utility classes and metaprogramming utilities used by the libcppa implementation. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor.html">actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all actor implementations.  <a href="classcppa_1_1actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__addressing.html">actor_addressing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different serialization protocols have different representations for actors. This class encapsulates a technology-specific actor addressing.  <a href="classcppa_1_1actor__addressing.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__companion__mixin.html">actor_companion_mixin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds co-existing objects (companions) to a class, which serve as gateways, thereby enabling libcppa's message passing.  <a href="classcppa_1_1actor__companion__mixin.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__proxy.html">actor_proxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a remote actor.  <a href="classcppa_1_1actor__proxy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a fixed-length copy-on-write tuple with elements of any type.  <a href="classcppa_1_1any__tuple.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1anything.html">anything</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acts as wildcard expression in patterns.  <a href="structcppa_1_1anything.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1is__anything.html">is_anything</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks wheter <code>T</code> is <a class="el" href="structcppa_1_1anything.html">anything</a>.  <a href="structcppa_1_1is__anything.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1attachable.html">attachable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback utility class.  <a href="classcppa_1_1attachable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1behavior.html">behavior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the behavior of an actor.  <a href="classcppa_1_1behavior.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1binary__deserializer.html">binary_deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the deserializer interface with a binary serialization protocol.  <a href="classcppa_1_1binary__deserializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1binary__serializer.html">binary_serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the serializer interface with a binary serialization protocol.  <a href="classcppa_1_1binary__serializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1channel.html">channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for all message receivers.  <a href="classcppa_1_1channel.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1context__switching__actor.html">context_switching_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context-switching actor implementation.  <a href="classcppa_1_1context__switching__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1cow__ptr.html">cow_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A copy-on-write smart pointer implementation.  <a href="classcppa_1_1cow__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1cow__tuple_3_01_head_00_01_tail_8_8_8_4.html">cow_tuple&lt; Head, Tail...&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed-length copy-on-write cow_tuple.  <a href="classcppa_1_1cow__tuple_3_01_head_00_01_tail_8_8_8_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1option.html">option</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an optional value of <code>T</code>.  <a href="classcppa_1_1option.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An intrusive, reference counting smart pointer impelementation.  <a href="classcppa_1_1intrusive__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1deserializer.html">deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Technology-independent deserialization interface.  <a href="classcppa_1_1deserializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1enable__weak__ptr.html">enable_weak_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables derived classes to be used in <a class="el" href="classcppa_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a>.  <a href="classcppa_1_1enable__weak__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1event__based__actor.html">event_based_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all event-based actor implementations.  <a href="classcppa_1_1event__based__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1cppa__exception.html">cppa_exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for libcppa exceptions.  <a href="classcppa_1_1cppa__exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1actor__exited.html">actor_exited</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown if an actor finished execution.  <a href="classcppa_1_1actor__exited.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1network__error.html">network_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown to indicate that either an actor publishing failed or <code>libcppa</code> was unable to connect to a remote host.  <a href="classcppa_1_1network__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1bind__failure.html">bind_failure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown to indicate that an actor publishing failed because the requested port could not be used.  <a href="classcppa_1_1bind__failure.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1extend.html">extend</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows convenient definition of types using mixins. For example, <code>extend&lt;ar,T&gt;::with&lt;ob,fo&gt;</code> is an alias for <code>fo&lt;ob&lt;ar,T&gt;</code>,T&gt;.  <a href="structcppa_1_1extend.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1group.html">group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multicast group.  <a href="classcppa_1_1group.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1guard__placeholder.html">guard_placeholder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for guard expression.  <a href="structcppa_1_1guard__placeholder.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1local__actor.html">local_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for local running Actors.  <a href="classcppa_1_1local__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1match__expr.html">match_expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A match expression encapsulating cases <code>Cs...</code>.  <a href="classcppa_1_1match__expr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1memory__cached.html">memory_cached</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mixin adds all member functions and member variables needed by the memory management subsystem.  <a href="classcppa_1_1memory__cached.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1memory__managed.html">memory_managed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base enables derived classes to enforce a different allocation strategy than new/delete by providing a virtual protected <code><a class="el" href="classcppa_1_1memory__managed.html#ae14e5c4be622520c604a9ac69f0c9478" title="Default implementations calls delete this, but can be overriden in case deletion depends on some cond...">request_deletion()</a></code> function and non-public destructor.  <a href="classcppa_1_1memory__managed.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1message__future.html">message_future</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the result of a synchronous send.  <a href="classcppa_1_1message__future.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1message__header.html">message_header</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates information about sender, receiver and (synchronous) message ID of a message. The message itself is usually an <a class="el" href="classcppa_1_1any__tuple.html" title="Describes a fixed-length copy-on-write tuple with elements of any type.">any_tuple</a>.  <a href="classcppa_1_1message__header.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1message__id.html">message_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1object.html">object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction class that stores an instance of an announced type.  <a href="classcppa_1_1object.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1option__info.html">option_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a help text along with the number of expected arguments.  <a href="structcppa_1_1option__info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcppa_1_1is__option.html">is_option</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1partial__function.html">partial_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partial function implementation for <a class="el" href="classcppa_1_1any__tuple.html">any_tuples</a>.  <a href="classcppa_1_1partial__function.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An union container for primitive data types.  <a href="classcppa_1_1primitive__variant.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1process__information.html">process_information</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies a process.  <a href="classcppa_1_1process__information.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1ref__counted.html">ref_counted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (thread safe) base class for reference counted objects with an atomic reference count.  <a href="classcppa_1_1ref__counted.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1response__handle.html">response_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes an outstanding response.  <a href="classcppa_1_1response__handle.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1sb__actor.html">sb_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for state-based actors using the Curiously Recurring Template Pattern to initialize the derived actor with its <code>init_state</code> member.  <a href="classcppa_1_1sb__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1scheduled__actor.html">scheduled_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for cooperatively scheduled actors.  <a href="classcppa_1_1scheduled__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1scheduler.html">scheduler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class allows to create (spawn) new actors and offers delayed sends.  <a href="classcppa_1_1scheduler.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1serializer.html">serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Technology-independent serialization interface.  <a href="classcppa_1_1serializer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores options passed to the <code>spawn</code> function family.  <a href="classcppa_1_1spawn__options.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1stacked.html">stacked</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An actor that uses the blocking API of <code>libcppa</code> and thus needs its own stack.  <a href="classcppa_1_1stacked.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1thread__mapped__actor.html">thread_mapped_actor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An actor using the blocking API running in its own thread.  <a href="classcppa_1_1thread__mapped__actor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a platform independent type name and a (very primitive) kind of reflection in combination with <a class="el" href="classcppa_1_1object.html">object</a>.  <a href="classcppa_1_1uniform__type__info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smart pointer that does not increase the reference count.  <a href="classcppa_1_1weak__intrusive__ptr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppa_1_1weak__ptr__anchor.html">weak_ptr_anchor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A storage holding a spinlock and a pointer to a reference counted object.  <a href="classcppa_1_1weak__ptr__anchor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a863e1b47946c1de002b6d01a6d02d606"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a863e1b47946c1de002b6d01a6d02d606"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcppa_1_1actor.html">actor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>actor_ptr</b></td></tr>
<tr class="separator:a863e1b47946c1de002b6d01a6d02d606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7838b52eb8d3c16d562e44f5b89629a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7838b52eb8d3c16d562e44f5b89629a4"></a>
template&lt;typename T , typename R  = void&gt; </td></tr>
<tr class="memitem:a7838b52eb8d3c16d562e44f5b89629a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a7838b52eb8d3c16d562e44f5b89629a4">enable_if_channel</a> = std::enable_if&lt; std::is_base_of&lt; <a class="el" href="classcppa_1_1channel.html">channel</a>, T &gt;::value, R &gt;</td></tr>
<tr class="memdesc:a7838b52eb8d3c16d562e44f5b89629a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias. <br/></td></tr>
<tr class="separator:a7838b52eb8d3c16d562e44f5b89629a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948e3ea11df8e64e9a0e0204d3d52539"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a948e3ea11df8e64e9a0e0204d3d52539"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>native_socket_type</b></td></tr>
<tr class="separator:a948e3ea11df8e64e9a0e0204d3d52539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8212243ffb4995abddd7850f47863b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8212243ffb4995abddd7850f47863b1"></a>
typedef const void *&#160;</td><td class="memItemRight" valign="bottom"><b>socket_send_ptr</b></td></tr>
<tr class="separator:af8212243ffb4995abddd7850f47863b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cea4187e4fa345b7cad0ca5c8e08af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41cea4187e4fa345b7cad0ca5c8e08af"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><b>socket_recv_ptr</b></td></tr>
<tr class="separator:a41cea4187e4fa345b7cad0ca5c8e08af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ee2cb32752d31e00d020c6cb7362e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60ee2cb32752d31e00d020c6cb7362e2"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcppa_1_1group.html">group</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>group_ptr</b></td></tr>
<tr class="separator:a60ee2cb32752d31e00d020c6cb7362e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac06fc2f69fb1021d95310238161c4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ac06fc2f69fb1021d95310238161c4e"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; <a class="el" href="classcppa_1_1channel.html">channel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>channel_ptr</b></td></tr>
<tr class="separator:a0ac06fc2f69fb1021d95310238161c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46190b719f248a02b0dcf748ac76b10f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46190b719f248a02b0dcf748ac76b10f"></a>
typedef behavior_policy&lt; false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>keep_behavior_t</b></td></tr>
<tr class="separator:a46190b719f248a02b0dcf748ac76b10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea2a0fe3f2f2a7f451d667a22b5940e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ea2a0fe3f2f2a7f451d667a22b5940e"></a>
typedef behavior_policy&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>discard_behavior_t</b></td></tr>
<tr class="separator:a7ea2a0fe3f2f2a7f451d667a22b5940e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8969803d282c6f1fe9b7641cd9357cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8969803d282c6f1fe9b7641cd9357cf"></a>
typedef std::map&lt; std::string, <br class="typebreak"/>
std::map&lt; std::pair&lt; char, <br class="typebreak"/>
std::string &gt;, <a class="el" href="structcppa_1_1option__info.html">option_info</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ab8969803d282c6f1fe9b7641cd9357cf">options_description</a></td></tr>
<tr class="memdesc:ab8969803d282c6f1fe9b7641cd9357cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a help text for program options with option groups. <br/></td></tr>
<tr class="separator:ab8969803d282c6f1fe9b7641cd9357cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02290ba27f0e00874bd507875e460e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae02290ba27f0e00874bd507875e460e2"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classcppa_1_1scheduled__actor.html">scheduled_actor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>scheduled_actor_ptr</b></td></tr>
<tr class="separator:ae02290ba27f0e00874bd507875e460e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d9c04c4339079df23bb8d6379645fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27d9c04c4339079df23bb8d6379645fa"></a>
typedef <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a><br class="typebreak"/>
&lt; <a class="el" href="classcppa_1_1thread__mapped__actor.html">thread_mapped_actor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>thread_mapped_actor_ptr</b></td></tr>
<tr class="separator:a27d9c04c4339079df23bb8d6379645fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7044eb06e2b94aaf9684d5d31e759f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f7044eb06e2b94aaf9684d5d31e759f"></a>
typedef timeout_definition<br class="typebreak"/>
&lt; std::function&lt; void()&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>generic_timeout_definition</b></td></tr>
<tr class="separator:a3f7044eb06e2b94aaf9684d5d31e759f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:abbace0a3a35eaf1c4c87d77d9ec29047"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>actor_state</b> : int { <br/>
&#160;&#160;<b>ready</b>, 
<br/>
&#160;&#160;<b>done</b>, 
<br/>
&#160;&#160;<b>blocked</b>, 
<br/>
&#160;&#160;<b>pending</b>, 
<br/>
&#160;&#160;<b>about_to_block</b>
<br/>
 }</td></tr>
<tr class="separator:abbace0a3a35eaf1c4c87d77d9ec29047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64079da560a7bd85135c11ab521a4950"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a64079da560a7bd85135c11ab521a4950">atom_value</a> : std::uint64_t </td></tr>
<tr class="memdesc:a64079da560a7bd85135c11ab521a4950"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type of atoms. <br/></td></tr>
<tr class="separator:a64079da560a7bd85135c11ab521a4950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32a52f8d2b456d1b5dbd2d0a3d3df34"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>operator_id</b> { <br/>
&#160;&#160;<b>addition_op</b>, 
<br/>
&#160;&#160;<b>subtraction_op</b>, 
<br/>
&#160;&#160;<b>multiplication_op</b>, 
<br/>
&#160;&#160;<b>division_op</b>, 
<br/>
&#160;&#160;<b>modulo_op</b>, 
<br/>
&#160;&#160;<b>less_op</b>, 
<br/>
&#160;&#160;<b>less_eq_op</b>, 
<br/>
&#160;&#160;<b>greater_op</b>, 
<br/>
&#160;&#160;<b>greater_eq_op</b>, 
<br/>
&#160;&#160;<b>equal_op</b>, 
<br/>
&#160;&#160;<b>not_equal_op</b>, 
<br/>
&#160;&#160;<b>logical_and_op</b>, 
<br/>
&#160;&#160;<b>logical_or_op</b>, 
<br/>
&#160;&#160;<b>exec_fun1_op</b>, 
<br/>
&#160;&#160;<b>exec_fun2_op</b>, 
<br/>
&#160;&#160;<b>exec_fun3_op</b>, 
<br/>
&#160;&#160;<b>exec_xfun_op</b>, 
<br/>
&#160;&#160;<b>dummy_op</b>
<br/>
 }</td></tr>
<tr class="separator:ae32a52f8d2b456d1b5dbd2d0a3d3df34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d951cd2881a098549c7393c470c8bee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>message_priority</b> { <br/>
&#160;&#160;<b>normal</b>, 
<br/>
&#160;&#160;<b>high</b>
<br/>
 }</td></tr>
<tr class="separator:a9d951cd2881a098549c7393c470c8bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4405c08180f3db0936dcc6afe84f2899"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899">primitive_type</a> : unsigned char { <br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899af3b4cd07f6e7b784ef327226d125f081">pt_int8</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899abe2fbca2e1841f8c22880cde2c00f542">pt_int16</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899aa0a3077bf98838f8565a3081bd45fe7a">pt_int32</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899adb00d323a0719b09a9b1e2b296bf7ee7">pt_int64</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a88cb8022596d4673fede279849a67c9e">pt_uint8</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899ac2fefdb86c724a8fccdaf77295bdb786">pt_uint16</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a081be63f60008807f9a07df1d814704a">pt_uint32</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a05e7b1ff7b99a9f24ff8a44577745d59">pt_uint64</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a9c2885b0dd3095de04714bf6d791ed61">pt_float</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a840b02ba715ef3b798d3f1b6cb1dd1bc">pt_double</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899afaa2282a22514a0934a3571b4e4cc75d">pt_long_double</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a93531ba3275cbc0a4cfcb23a6bbe080e">pt_u8string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899ab2a366dcc7a5b7ee1162fd024d6f722e">pt_u16string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899ac04250078e159cbbb285ad3a39aae4ce">pt_u32string</a>, 
<br/>
&#160;&#160;<a class="el" href="group___type_system.html#gga4405c08180f3db0936dcc6afe84f2899a494ed640f1e094e7db23a9ce2f3f199b">pt_null</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga4405c08180f3db0936dcc6afe84f2899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type flag of <a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a>.  <a href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899">More...</a><br/></td></tr>
<tr class="separator:ga4405c08180f3db0936dcc6afe84f2899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af816c542cfd937e5e9da9c9b88304c43"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>resume_result</b> { <br/>
&#160;&#160;<b>actor_blocked</b>, 
<br/>
&#160;&#160;<b>actor_done</b>
<br/>
 }</td></tr>
<tr class="separator:af816c542cfd937e5e9da9c9b88304c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5170d2d86c130ef4375778aa90aec596"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>scheduled_actor_type</b> { <br/>
&#160;&#160;<b>context_switching_impl</b>, 
<br/>
&#160;&#160;<b>event_based_impl</b>, 
<br/>
&#160;&#160;<b>default_event_based_impl</b>
<br/>
 }</td></tr>
<tr class="separator:a5170d2d86c130ef4375778aa90aec596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab63f2274711ea5cce959c91d793b25"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5ab63f2274711ea5cce959c91d793b25">wildcard_position</a> { <br/>
&#160;&#160;<b>nil</b>, 
<br/>
&#160;&#160;<b>trailing</b>, 
<br/>
&#160;&#160;<b>leading</b>, 
<br/>
&#160;&#160;<b>in_between</b>, 
<br/>
&#160;&#160;<b>multiple</b>
<br/>
 }</td></tr>
<tr class="memdesc:a5ab63f2274711ea5cce959c91d793b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes the position of <a class="el" href="structcppa_1_1anything.html">anything</a> in a template parameter pack. <br/></td></tr>
<tr class="separator:a5ab63f2274711ea5cce959c91d793b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a40beebfb988f17b8698c209906b13667"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40beebfb988f17b8698c209906b13667"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> &amp;, const self_type &amp;)</td></tr>
<tr class="separator:a40beebfb988f17b8698c209906b13667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2bbc491f12a4e7817a6c297fd3a836"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade2bbc491f12a4e7817a6c297fd3a836"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const self_type &amp;, const <a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> &amp;)</td></tr>
<tr class="separator:ade2bbc491f12a4e7817a6c297fd3a836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f73c466e0356b08161d77769aeb726f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga7f73c466e0356b08161d77769aeb726f">announce</a> (const std::type_info &amp;tinfo, <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> *utype)</td></tr>
<tr class="memdesc:ga7f73c466e0356b08161d77769aeb726f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new type mapping to the libcppa type system.  <a href="group___type_system.html#ga7f73c466e0356b08161d77769aeb726f">More...</a><br/></td></tr>
<tr class="separator:ga7f73c466e0356b08161d77769aeb726f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf92877da942d1a0f1944990cd3d67f7c"><td class="memTemplParams" colspan="2">template&lt;class C , class Parent , typename... Ts&gt; </td></tr>
<tr class="memitem:gaf92877da942d1a0f1944990cd3d67f7c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; C Parent::*, <br class="typebreak"/>
<a class="el" href="classcppa_1_1util_1_1abstract__uniform__type__info.html">util::abstract_uniform_type_info</a><br class="typebreak"/>
&lt; C &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#gaf92877da942d1a0f1944990cd3d67f7c">compound_member</a> (C Parent::*c_ptr, const Ts &amp;...args)</td></tr>
<tr class="memdesc:gaf92877da942d1a0f1944990cd3d67f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member <code>C</code>.  <a href="group___type_system.html#gaf92877da942d1a0f1944990cd3d67f7c">More...</a><br/></td></tr>
<tr class="separator:gaf92877da942d1a0f1944990cd3d67f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1400abaf4c109b60eba1f83d417b65c"><td class="memTemplParams" colspan="2">template&lt;class C , class Parent , typename... Ts&gt; </td></tr>
<tr class="memitem:gaf1400abaf4c109b60eba1f83d417b65c"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; C &amp;(Parent::*)(), <br class="typebreak"/>
<a class="el" href="classcppa_1_1util_1_1abstract__uniform__type__info.html">util::abstract_uniform_type_info</a><br class="typebreak"/>
&lt; C &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#gaf1400abaf4c109b60eba1f83d417b65c">compound_member</a> (C &amp;(Parent::*getter)(), const Ts &amp;...args)</td></tr>
<tr class="memdesc:gaf1400abaf4c109b60eba1f83d417b65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member accessed via a getter returning a mutable reference.  <a href="group___type_system.html#gaf1400abaf4c109b60eba1f83d417b65c">More...</a><br/></td></tr>
<tr class="separator:gaf1400abaf4c109b60eba1f83d417b65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e20c330342ba3b8c0ae9de2cf4f33fb"><td class="memTemplParams" colspan="2">template&lt;class Parent , typename GRes , typename SRes , typename SArg , typename... Ts&gt; </td></tr>
<tr class="memitem:ga0e20c330342ba3b8c0ae9de2cf4f33fb"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; GRes(Parent::*)() <br class="typebreak"/>
const, SRes(Parent::*)(SArg)&gt;<br class="typebreak"/>
, <a class="el" href="classcppa_1_1util_1_1abstract__uniform__type__info.html">util::abstract_uniform_type_info</a><br class="typebreak"/>
&lt; typename <a class="el" href="structcppa_1_1util_1_1rm__ref.html">util::rm_ref</a>&lt; GRes &gt;<br class="typebreak"/>
::type &gt; * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga0e20c330342ba3b8c0ae9de2cf4f33fb">compound_member</a> (const std::pair&lt; GRes(Parent::*)() const, SRes(Parent::*)(SArg) &gt; &amp;gspair, const Ts &amp;...args)</td></tr>
<tr class="memdesc:ga0e20c330342ba3b8c0ae9de2cf4f33fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates meta informations for a non-trivial member accessed via a getter/setter pair.  <a href="group___type_system.html#ga0e20c330342ba3b8c0ae9de2cf4f33fb">More...</a><br/></td></tr>
<tr class="separator:ga0e20c330342ba3b8c0ae9de2cf4f33fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b5f6f7645a97dcefa4abdf6becde780"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ga5b5f6f7645a97dcefa4abdf6becde780"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga5b5f6f7645a97dcefa4abdf6becde780">announce</a> (const Ts &amp;...args)</td></tr>
<tr class="memdesc:ga5b5f6f7645a97dcefa4abdf6becde780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new type mapping for <code>T</code> to the libcppa type system.  <a href="group___type_system.html#ga5b5f6f7645a97dcefa4abdf6becde780">More...</a><br/></td></tr>
<tr class="separator:ga5b5f6f7645a97dcefa4abdf6becde780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cd5b37281764af3f24ba8ca297c2f3"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a28cd5b37281764af3f24ba8ca297c2f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a28cd5b37281764af3f24ba8ca297c2f3">make_any_tuple</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a28cd5b37281764af3f24ba8ca297c2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> containing the elements <code>args</code>.  <a href="#a28cd5b37281764af3f24ba8ca297c2f3">More...</a><br/></td></tr>
<tr class="separator:a28cd5b37281764af3f24ba8ca297c2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a9f2873d0e97eb7ceffb6101e8e507"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a76a9f2873d0e97eb7ceffb6101e8e507">to_string</a> (const <a class="el" href="namespacecppa.html#a64079da560a7bd85135c11ab521a4950">atom_value</a> &amp;what)</td></tr>
<tr class="memdesc:a76a9f2873d0e97eb7ceffb6101e8e507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>what</code> as a string representation.  <a href="#a76a9f2873d0e97eb7ceffb6101e8e507">More...</a><br/></td></tr>
<tr class="separator:a76a9f2873d0e97eb7ceffb6101e8e507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed5b5aa07c384b14899beae80974d47"><td class="memTemplParams" colspan="2">template&lt;size_t Size&gt; </td></tr>
<tr class="memitem:a9ed5b5aa07c384b14899beae80974d47"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecppa.html#a64079da560a7bd85135c11ab521a4950">atom_value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47">atom</a> (char const (&amp;str)[Size])</td></tr>
<tr class="memdesc:a9ed5b5aa07c384b14899beae80974d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an atom from given string literal.  <a href="#a9ed5b5aa07c384b14899beae80974d47">More...</a><br/></td></tr>
<tr class="separator:a9ed5b5aa07c384b14899beae80974d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f35f5fe58e287026a0149f341e8e3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41f35f5fe58e287026a0149f341e8e3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>closesocket</b> (native_socket_type fd)</td></tr>
<tr class="separator:a41f35f5fe58e287026a0149f341e8e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1915f591fedcf4e5cd25efe9a800da57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1915f591fedcf4e5cd25efe9a800da57"></a>
<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>eval_sopts</b> (<a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a> opts, local_actor_ptr ptr)</td></tr>
<tr class="separator:a1915f591fedcf4e5cd25efe9a800da57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185090573ffb146384ccdfa94172c23e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a185090573ffb146384ccdfa94172c23e">await_all_others_done</a> ()</td></tr>
<tr class="memdesc:a185090573ffb146384ccdfa94172c23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks execution of this actor until all other actors finished execution.  <a href="#a185090573ffb146384ccdfa94172c23e">More...</a><br/></td></tr>
<tr class="separator:a185090573ffb146384ccdfa94172c23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487e6c08f5f4f7de4775418547f7e93e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a487e6c08f5f4f7de4775418547f7e93e">publish</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> whom, std::uint16_t port, const char *addr=nullptr)</td></tr>
<tr class="memdesc:a487e6c08f5f4f7de4775418547f7e93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publishes <code>whom</code> at <code>port</code>.  <a href="#a487e6c08f5f4f7de4775418547f7e93e">More...</a><br/></td></tr>
<tr class="separator:a487e6c08f5f4f7de4775418547f7e93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c73df0929df9b069096d3d9f9499bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ad9c73df0929df9b069096d3d9f9499bf">publish</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> whom, std::unique_ptr&lt; <a class="el" href="classcppa_1_1network_1_1acceptor.html">network::acceptor</a> &gt; acceptor)</td></tr>
<tr class="memdesc:ad9c73df0929df9b069096d3d9f9499bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Publishes <code>whom</code> using <code>acceptor</code> to handle incoming connections.  <a href="#ad9c73df0929df9b069096d3d9f9499bf">More...</a><br/></td></tr>
<tr class="separator:ad9c73df0929df9b069096d3d9f9499bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76739f7f372b92999ee9b80d332093bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a76739f7f372b92999ee9b80d332093bd">remote_actor</a> (const char *host, std::uint16_t port)</td></tr>
<tr class="memdesc:a76739f7f372b92999ee9b80d332093bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to the actor at <code>host</code> on given <code>port</code>.  <a href="#a76739f7f372b92999ee9b80d332093bd">More...</a><br/></td></tr>
<tr class="separator:a76739f7f372b92999ee9b80d332093bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e44ab5ef88ac98dd909f3a09bbf181d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a1e44ab5ef88ac98dd909f3a09bbf181d">remote_actor</a> (const std::string &amp;host, std::uint16_t port)</td></tr>
<tr class="memdesc:a1e44ab5ef88ac98dd909f3a09bbf181d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to the actor at <code>host</code> on given <code>port</code>.  <a href="#a1e44ab5ef88ac98dd909f3a09bbf181d">More...</a><br/></td></tr>
<tr class="separator:a1e44ab5ef88ac98dd909f3a09bbf181d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39f7d863455eec31681ebd1879e4fd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aa39f7d863455eec31681ebd1879e4fd6">remote_actor</a> (<a class="el" href="namespacecppa_1_1network.html#a4615e80cb9a1a5925e5598b46348afc2">network::io_stream_ptr_pair</a> connection)</td></tr>
<tr class="memdesc:aa39f7d863455eec31681ebd1879e4fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establish a new connection to the actor via given <code>connection</code>.  <a href="#aa39f7d863455eec31681ebd1879e4fd6">More...</a><br/></td></tr>
<tr class="separator:aa39f7d863455eec31681ebd1879e4fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5daac288a10cc34286f505ea637571"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d5daac288a10cc34286f505ea637571"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a8d5daac288a10cc34286f505ea637571">shutdown</a> ()</td></tr>
<tr class="memdesc:a8d5daac288a10cc34286f505ea637571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all singletons, disconnects all peers and stops the scheduler. It is recommended to use this function as very last function call before leaving main(). Especially in programs using libcppa's networking infrastructure. <br/></td></tr>
<tr class="separator:a8d5daac288a10cc34286f505ea637571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a903f4246f9e5bab78c06f666e8ee4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#af7a903f4246f9e5bab78c06f666e8ee4">send_exit</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> whom, std::uint32_t reason)</td></tr>
<tr class="memdesc:af7a903f4246f9e5bab78c06f666e8ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an exit message to <code>whom</code> with <code>reason</code>.  <a href="#af7a903f4246f9e5bab78c06f666e8ee4">More...</a><br/></td></tr>
<tr class="separator:af7a903f4246f9e5bab78c06f666e8ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986eecdd2b299c92f63ffce21076dee6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a986eecdd2b299c92f63ffce21076dee6"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a986eecdd2b299c92f63ffce21076dee6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a986eecdd2b299c92f63ffce21076dee6">become</a> (T arg, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:a986eecdd2b299c92f63ffce21076dee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the actor's behavior and discards the previous behavior unless <a class="el" href="">keep_behavior</a> is given as first argument. <br/></td></tr>
<tr class="separator:a986eecdd2b299c92f63ffce21076dee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb78c2b86b38c9deb5db6f37012d94e9"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb78c2b86b38c9deb5db6f37012d94e9"></a>
template&lt;bool Discard, typename... Ts&gt; </td></tr>
<tr class="memitem:abb78c2b86b38c9deb5db6f37012d94e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>become</b> (behavior_policy&lt; Discard &gt;, Ts &amp;&amp;...args)</td></tr>
<tr class="separator:abb78c2b86b38c9deb5db6f37012d94e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bfd1a9574057e1470ea7d26167ba18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1bfd1a9574057e1470ea7d26167ba18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ae1bfd1a9574057e1470ea7d26167ba18">unbecome</a> ()</td></tr>
<tr class="memdesc:ae1bfd1a9574057e1470ea7d26167ba18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns to a previous behavior if available. <br/></td></tr>
<tr class="separator:ae1bfd1a9574057e1470ea7d26167ba18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08349cb93c162f2d9cfd274ae53e6b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae08349cb93c162f2d9cfd274ae53e6b3"></a>
const actor_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const actor_ostream &amp;o, std::string arg)</td></tr>
<tr class="separator:ae08349cb93c162f2d9cfd274ae53e6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58f34b5d1df5cb163efe061d8465787"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab58f34b5d1df5cb163efe061d8465787"></a>
const actor_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const actor_ostream &amp;o, const <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> &amp;arg)</td></tr>
<tr class="separator:ab58f34b5d1df5cb163efe061d8465787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd724d4ad45e6882f875bde0a4c28a4d"><td class="memTemplParams" colspan="2"><a class="anchor" id="afd724d4ad45e6882f875bde0a4c28a4d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd724d4ad45e6882f875bde0a4c28a4d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; !std::is_convertible&lt; T, <br class="typebreak"/>
std::string &gt;::value <br class="typebreak"/>
&amp;&amp;!std::is_convertible&lt; T, <br class="typebreak"/>
<a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> &gt;::value, const <br class="typebreak"/>
actor_ostream &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const actor_ostream &amp;o, T &amp;&amp;arg)</td></tr>
<tr class="separator:afd724d4ad45e6882f875bde0a4c28a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca5dce51a19e691510357f726bcb3e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ca5dce51a19e691510357f726bcb3e5"></a>
const actor_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const actor_ostream &amp;o, actor_ostream::fun_type f)</td></tr>
<tr class="separator:a3ca5dce51a19e691510357f726bcb3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa221547ef879ba5b42f7cc7820f90e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1object.html">object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aaa221547ef879ba5b42f7cc7820f90e1">from_string</a> (const std::string &amp;what)</td></tr>
<tr class="memdesc:aaa221547ef879ba5b42f7cc7820f90e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string created by <a class="el" href="namespacecppa.html#a76a9f2873d0e97eb7ceffb6101e8e507">to_string</a> to its original value.  <a href="#aaa221547ef879ba5b42f7cc7820f90e1">More...</a><br/></td></tr>
<tr class="separator:aaa221547ef879ba5b42f7cc7820f90e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87616c092a1ee72dca2229e445145f3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad87616c092a1ee72dca2229e445145f3"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:ad87616c092a1ee72dca2229e445145f3"><td class="memTemplItemLeft" align="right" valign="top">const util::at&lt; N, Ts...&gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const detail::tdata&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:ad87616c092a1ee72dca2229e445145f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1923959d567ee7938409e2de48bfd81e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1923959d567ee7938409e2de48bfd81e"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:a1923959d567ee7938409e2de48bfd81e"><td class="memTemplItemLeft" align="right" valign="top">const util::at&lt; N, Ts...&gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const cow_tuple&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:a1923959d567ee7938409e2de48bfd81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09d6b9b2dd133a475f1a5cb21b263ad"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa09d6b9b2dd133a475f1a5cb21b263ad"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:aa09d6b9b2dd133a475f1a5cb21b263ad"><td class="memTemplItemLeft" align="right" valign="top">const util::at&lt; N, Ts...&gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const detail::pseudo_tuple&lt; Ts...&gt; &amp;tv)</td></tr>
<tr class="separator:aa09d6b9b2dd133a475f1a5cb21b263ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa751a1611e1a4c99218270c18074a28c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa751a1611e1a4c99218270c18074a28c"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:aa751a1611e1a4c99218270c18074a28c"><td class="memTemplItemLeft" align="right" valign="top">util::at&lt; N, Ts...&gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="structcppa_1_1util_1_1type__list.html">util::type_list</a>&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:aa751a1611e1a4c99218270c18074a28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5a402e86da353531d303e469c44eb3"><td class="memTemplParams" colspan="2"><a class="anchor" id="adc5a402e86da353531d303e469c44eb3"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:adc5a402e86da353531d303e469c44eb3"><td class="memTemplItemLeft" align="right" valign="top">util::at&lt; N, Ts...&gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (detail::tdata&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:adc5a402e86da353531d303e469c44eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6bb4782f47bec9481fb05dafa519dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0a6bb4782f47bec9481fb05dafa519dd"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:a0a6bb4782f47bec9481fb05dafa519dd"><td class="memTemplItemLeft" align="right" valign="top">util::at&lt; N, Ts...&gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (cow_tuple&lt; Ts...&gt; &amp;)</td></tr>
<tr class="separator:a0a6bb4782f47bec9481fb05dafa519dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bd6aabeaa757a1e3ff2a8372c88dc4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1bd6aabeaa757a1e3ff2a8372c88dc4"></a>
template&lt;size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:ae1bd6aabeaa757a1e3ff2a8372c88dc4"><td class="memTemplItemLeft" align="right" valign="top">util::at&lt; N, Ts...&gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (detail::pseudo_tuple&lt; Ts...&gt; &amp;tv)</td></tr>
<tr class="separator:ae1bd6aabeaa757a1e3ff2a8372c88dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b50642f923d63806735ee22b9f2be8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab3b50642f923d63806735ee22b9f2be8"></a>
template&lt;size_t Pos, typename... Ts&gt; </td></tr>
<tr class="memitem:ab3b50642f923d63806735ee22b9f2be8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (std::tuple&lt; Ts...&gt; &amp;tup) -&gt; decltype(std::get&lt; Pos &gt;(tup))</td></tr>
<tr class="separator:ab3b50642f923d63806735ee22b9f2be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c26044ba1f8a78aa4d43cd13e2a9abe"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7c26044ba1f8a78aa4d43cd13e2a9abe"></a>
template&lt;size_t Pos, class Tuple &gt; </td></tr>
<tr class="memitem:a7c26044ba1f8a78aa4d43cd13e2a9abe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a7c26044ba1f8a78aa4d43cd13e2a9abe">get_cv_aware</a> (Tuple &amp;tup) -&gt; decltype(get_ref&lt; Pos &gt;(tup))</td></tr>
<tr class="memdesc:a7c26044ba1f8a78aa4d43cd13e2a9abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function grants either const or non-const access to <code>tup</code>, depending on the cv-qualifier of <code>tup</code>. <br/></td></tr>
<tr class="separator:a7c26044ba1f8a78aa4d43cd13e2a9abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6a41ff1aa0eefc3e1413cda6519dd1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0c6a41ff1aa0eefc3e1413cda6519dd1"></a>
template&lt;size_t Pos, class Tuple &gt; </td></tr>
<tr class="memitem:a0c6a41ff1aa0eefc3e1413cda6519dd1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a0c6a41ff1aa0eefc3e1413cda6519dd1">get_cv_aware</a> (const Tuple &amp;tup) -&gt; decltype(get&lt; Pos &gt;(tup))</td></tr>
<tr class="memdesc:a0c6a41ff1aa0eefc3e1413cda6519dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function grants either const or non-const access to <code>tup</code>, depending on the cv-qualifier of <code>tup</code>. <br/></td></tr>
<tr class="separator:a0c6a41ff1aa0eefc3e1413cda6519dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae213a56201820111919afe92aa287586"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ae213a56201820111919afe92aa287586">publish_local_groups_at</a> (std::uint16_t port, const char *addr=nullptr)</td></tr>
<tr class="memdesc:ae213a56201820111919afe92aa287586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes <em>all</em> local groups accessible via network on address <code>addr</code> and <code>port</code>.  <a href="#ae213a56201820111919afe92aa287586">More...</a><br/></td></tr>
<tr class="separator:ae213a56201820111919afe92aa287586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ab2c74affc2496609bacf3be1f46de"><td class="memTemplParams" colspan="2"><a class="anchor" id="a17ab2c74affc2496609bacf3be1f46de"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17ab2c74affc2496609bacf3be1f46de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1util_1_1rebindable__reference.html">util::rebindable_reference</a><br class="typebreak"/>
&lt; const T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a17ab2c74affc2496609bacf3be1f46de">gref</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a17ab2c74affc2496609bacf3be1f46de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a reference wrapper similar to std::reference_wrapper&lt;const T&gt; that could be used in guard expressions or to enforce lazy evaluation. <br/></td></tr>
<tr class="separator:a17ab2c74affc2496609bacf3be1f46de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef395eaa7bd389ba17e28867010b5a7e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aef395eaa7bd389ba17e28867010b5a7e"></a>
template&lt;typename Fun , typename T1 &gt; </td></tr>
<tr class="memitem:aef395eaa7bd389ba17e28867010b5a7e"><td class="memTemplItemLeft" align="right" valign="top">gcall1&lt; Fun, T1 &gt;::result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aef395eaa7bd389ba17e28867010b5a7e">gcall</a> (Fun fun, T1 t1)</td></tr>
<tr class="memdesc:aef395eaa7bd389ba17e28867010b5a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call wrapper for guard placeholders and lazy evaluation. <br/></td></tr>
<tr class="separator:aef395eaa7bd389ba17e28867010b5a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a444ff11a730b8c1d42d5499c8fd36ed0"></a>
template&lt;typename Fun , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="memTemplItemLeft" align="right" valign="top">gcall2&lt; Fun, T1, T2 &gt;::result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a444ff11a730b8c1d42d5499c8fd36ed0">gcall</a> (Fun fun, T1 t1, T2 t2)</td></tr>
<tr class="memdesc:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call wrapper for guard placeholders and lazy evaluation. <br/></td></tr>
<tr class="separator:a444ff11a730b8c1d42d5499c8fd36ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb38db3897563dd010b0159b7598ce24"><td class="memTemplParams" colspan="2"><a class="anchor" id="afb38db3897563dd010b0159b7598ce24"></a>
template&lt;typename Fun , typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:afb38db3897563dd010b0159b7598ce24"><td class="memTemplItemLeft" align="right" valign="top">gcall3&lt; Fun, T1, T2, T3 &gt;::result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#afb38db3897563dd010b0159b7598ce24">gcall</a> (Fun fun, T1 t1, T2 t2, T3 t3)</td></tr>
<tr class="memdesc:afb38db3897563dd010b0159b7598ce24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call wrapper for guard placeholders and lazy evaluation. <br/></td></tr>
<tr class="separator:afb38db3897563dd010b0159b7598ce24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ca2ae4516ac8c2d09825bf16e06399"><td class="memTemplParams" colspan="2"><a class="anchor" id="a11ca2ae4516ac8c2d09825bf16e06399"></a>
template&lt;typename Fun &gt; </td></tr>
<tr class="memitem:a11ca2ae4516ac8c2d09825bf16e06399"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; exec_xfun_op, Fun, <br class="typebreak"/>
util::void_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a11ca2ae4516ac8c2d09825bf16e06399">ge_sub_function</a> (Fun fun)</td></tr>
<tr class="memdesc:a11ca2ae4516ac8c2d09825bf16e06399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>fun</code> with all arguments given to the guard expression. The functor <code>fun</code> must return a boolean. <br/></td></tr>
<tr class="separator:a11ca2ae4516ac8c2d09825bf16e06399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832d63b8b90c03075666e5b709805222"><td class="memTemplParams" colspan="2"><a class="anchor" id="a832d63b8b90c03075666e5b709805222"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a832d63b8b90c03075666e5b709805222"><td class="memTemplItemLeft" align="right" valign="top">ge_value&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>gval</b> (T <a class="el" href="namespacecppa.html#af928936d573122345bc0737615f95f33">val</a>)</td></tr>
<tr class="separator:a832d63b8b90c03075666e5b709805222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6efd772c183821806213315e16c30c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aee6efd772c183821806213315e16c30c"></a>
template&lt;operator_id OP, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aee6efd772c183821806213315e16c30c"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; OP, typename <br class="typebreak"/>
detail::strip_and_convert&lt; T1 &gt;<br class="typebreak"/>
::type, typename <br class="typebreak"/>
detail::strip_and_convert&lt; T2 &gt;<br class="typebreak"/>
::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_concatenate</b> (T1 first, T2 second, typename std::enable_if&lt; is_ge_type&lt; T1 &gt;::value||is_ge_type&lt; T2 &gt;::value &gt;::type *=0)</td></tr>
<tr class="separator:aee6efd772c183821806213315e16c30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ae21ec736d7c79de5bc814efab66ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a55ae21ec736d7c79de5bc814efab66ca"></a>
template&lt;operator_id OP1, typename F1 , typename S1 , operator_id OP2, typename F2 , typename S2 &gt; </td></tr>
<tr class="memitem:a55ae21ec736d7c79de5bc814efab66ca"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; logical_and_op, <br class="typebreak"/>
guard_expr&lt; OP1, F1, S1 &gt;<br class="typebreak"/>
, guard_expr&lt; OP2, F2, S2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (guard_expr&lt; OP1, F1, S1 &gt; lhs, guard_expr&lt; OP2, F2, S2 &gt; rhs)</td></tr>
<tr class="separator:a55ae21ec736d7c79de5bc814efab66ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628c9ea9c68a69a765e1c22ebab625b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a628c9ea9c68a69a765e1c22ebab625b9"></a>
template&lt;operator_id OP1, typename F1 , typename S1 , operator_id OP2, typename F2 , typename S2 &gt; </td></tr>
<tr class="memitem:a628c9ea9c68a69a765e1c22ebab625b9"><td class="memTemplItemLeft" align="right" valign="top">guard_expr&lt; logical_or_op, <br class="typebreak"/>
guard_expr&lt; OP1, F1, S1 &gt;<br class="typebreak"/>
, guard_expr&lt; OP2, F2, S2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (guard_expr&lt; OP1, F1, S1 &gt; lhs, guard_expr&lt; OP2, F2, S2 &gt; rhs)</td></tr>
<tr class="separator:a628c9ea9c68a69a765e1c22ebab625b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df0ac35ccc8aca49cfd042f977a375b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3df0ac35ccc8aca49cfd042f977a375b"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:a3df0ac35ccc8aca49cfd042f977a375b"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const T &amp;value)</td></tr>
<tr class="separator:a3df0ac35ccc8aca49cfd042f977a375b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44077174990342ce322b5c720af285a7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a44077174990342ce322b5c720af285a7"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:a44077174990342ce322b5c720af285a7"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const std::reference_wrapper&lt; T &gt; &amp;value)</td></tr>
<tr class="separator:a44077174990342ce322b5c720af285a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4027bf874a6ff4ad23d688ffe08544"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f4027bf874a6ff4ad23d688ffe08544"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:a2f4027bf874a6ff4ad23d688ffe08544"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const std::reference_wrapper&lt; const T &gt; &amp;value)</td></tr>
<tr class="separator:a2f4027bf874a6ff4ad23d688ffe08544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dea78fc9947ec1611c055242acad42"><td class="memTemplParams" colspan="2"><a class="anchor" id="af2dea78fc9947ec1611c055242acad42"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:af2dea78fc9947ec1611c055242acad42"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const <a class="el" href="classcppa_1_1util_1_1rebindable__reference.html">util::rebindable_reference</a>&lt; const T &gt; &amp;value)</td></tr>
<tr class="separator:af2dea78fc9947ec1611c055242acad42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2410091863897048954dde384e70df"><td class="memTemplParams" colspan="2"><a class="anchor" id="ace2410091863897048954dde384e70df"></a>
template&lt;class Tuple , typename T &gt; </td></tr>
<tr class="memitem:ace2410091863897048954dde384e70df"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;, const ge_value&lt; T &gt; &amp;wrapped_value)</td></tr>
<tr class="separator:ace2410091863897048954dde384e70df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89265fd784a63cdd2d9143c74e6f2f94"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89265fd784a63cdd2d9143c74e6f2f94"></a>
template&lt;class Tuple , int X&gt; </td></tr>
<tr class="memitem:a89265fd784a63cdd2d9143c74e6f2f94"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;tup, <a class="el" href="structcppa_1_1guard__placeholder.html">guard_placeholder</a>&lt; X &gt;) -&gt; decltype(get&lt; X &gt;(tup).get())</td></tr>
<tr class="separator:a89265fd784a63cdd2d9143c74e6f2f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b5290d7cca52854f219727919d56d5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a83b5290d7cca52854f219727919d56d5"></a>
template&lt;class Tuple , operator_id OP, typename First , typename Second &gt; </td></tr>
<tr class="memitem:a83b5290d7cca52854f219727919d56d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_resolve</b> (const Tuple &amp;tup, const guard_expr&lt; OP, First, Second &gt; &amp;ge) -&gt; typename ge_result&lt; OP, First, Second, Tuple &gt;::type</td></tr>
<tr class="separator:a83b5290d7cca52854f219727919d56d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3c9b3d2cf91e86fbefa608b71b6ed1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c3c9b3d2cf91e86fbefa608b71b6ed1"></a>
template&lt;operator_id OP, class Tuple , typename First , typename Second &gt; </td></tr>
<tr class="memitem:a3c3c9b3d2cf91e86fbefa608b71b6ed1"><td class="memTemplItemLeft" align="right" valign="top">ge_result&lt; OP, First, Second, <br class="typebreak"/>
Tuple &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_eval</b> (const Tuple &amp;tup, const First &amp;lhs, const Second &amp;rhs)</td></tr>
<tr class="separator:a3c3c9b3d2cf91e86fbefa608b71b6ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f59e94232ea05ac9753812211e33f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a93f59e94232ea05ac9753812211e33f1"></a>
template&lt;operator_id OP, typename First , typename Second , typename... Ts&gt; </td></tr>
<tr class="memitem:a93f59e94232ea05ac9753812211e33f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_invoke_step2</b> (const guard_expr&lt; OP, First, Second &gt; &amp;ge, const detail::tdata&lt; Ts...&gt; &amp;tup) -&gt; typename ge_result&lt; OP, First, Second, detail::tdata&lt; Ts...&gt;&gt;::type</td></tr>
<tr class="separator:a93f59e94232ea05ac9753812211e33f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439d948767945bc2fccd61fe7bb31d44"><td class="memTemplParams" colspan="2"><a class="anchor" id="a439d948767945bc2fccd61fe7bb31d44"></a>
template&lt;operator_id OP, typename First , typename Second , typename... Ts&gt; </td></tr>
<tr class="memitem:a439d948767945bc2fccd61fe7bb31d44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_invoke</b> (const guard_expr&lt; OP, First, Second &gt; &amp;ge, const Ts &amp;...args) -&gt; typename ge_result&lt; OP, First, Second, detail::tdata&lt; std::reference_wrapper&lt; const Ts &gt;...&gt;&gt;::type</td></tr>
<tr class="separator:a439d948767945bc2fccd61fe7bb31d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a82a93906c827b7ada3f6ffe195a56"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab2a82a93906c827b7ada3f6ffe195a56"></a>
template&lt;typename TupleTypes , operator_id OP, typename First , typename Second &gt; </td></tr>
<tr class="memitem:ab2a82a93906c827b7ada3f6ffe195a56"><td class="memTemplItemLeft" align="right" valign="top">ge_result&lt; OP, First, Second, <br class="typebreak"/>
typename <br class="typebreak"/>
detail::tdata_from_type_list<br class="typebreak"/>
&lt; typename <a class="el" href="structcppa_1_1util_1_1tl__filter__not.html">util::tl_filter_not</a><br class="typebreak"/>
&lt; TupleTypes, <a class="el" href="structcppa_1_1is__anything.html">is_anything</a> &gt;<br class="typebreak"/>
::type &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ge_invoke_any</b> (const guard_expr&lt; OP, First, Second &gt; &amp;ge, const <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> &amp;tup)</td></tr>
<tr class="separator:ab2a82a93906c827b7ada3f6ffe195a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae235ed79838ec2a5697233ca045c34"><td class="memTemplParams" colspan="2"><a class="anchor" id="afae235ed79838ec2a5697233ca045c34"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:afae235ed79838ec2a5697233ca045c34"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if<br class="typebreak"/>
&lt; is_memory_cached&lt; T &gt;::value, <br class="typebreak"/>
<a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#afae235ed79838ec2a5697233ca045c34">make_counted</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:afae235ed79838ec2a5697233ca045c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an object of type T which must be a derived type of <a class="el" href="classcppa_1_1ref__counted.html">ref_counted</a> and wraps it in an <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>. <br/></td></tr>
<tr class="separator:afae235ed79838ec2a5697233ca045c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e4ed4baca6384500d560506ff06088"><td class="memTemplParams" colspan="2"><a class="anchor" id="a38e4ed4baca6384500d560506ff06088"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a38e4ed4baca6384500d560506ff06088"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; not <br class="typebreak"/>
is_memory_cached&lt; T &gt;::value, <br class="typebreak"/>
<a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_counted</b> (Ts &amp;&amp;...args)</td></tr>
<tr class="separator:a38e4ed4baca6384500d560506ff06088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db87bb3f005546ffb41a164653788ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3db87bb3f005546ffb41a164653788ae"></a>
<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fwd_aptr</b> (const self_type &amp;s)</td></tr>
<tr class="separator:a3db87bb3f005546ffb41a164653788ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c216cb49f17a377f29486581861f27d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c216cb49f17a377f29486581861f27d"></a>
<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fwd_aptr</b> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> ptr)</td></tr>
<tr class="separator:a8c216cb49f17a377f29486581861f27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef26aeefd5299203995aa3733d25525b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef26aeefd5299203995aa3733d25525b"></a>
oss_wr&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (oss_wr &amp;&amp;lhs, std::string str)</td></tr>
<tr class="separator:aef26aeefd5299203995aa3733d25525b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717c7a06002e2d309d76eaf5c05a4f28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a717c7a06002e2d309d76eaf5c05a4f28"></a>
oss_wr&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (oss_wr &amp;&amp;lhs, const char *str)</td></tr>
<tr class="separator:a717c7a06002e2d309d76eaf5c05a4f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56abb51f6a9aec9ed8d1abb736adc064"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56abb51f6a9aec9ed8d1abb736adc064"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56abb51f6a9aec9ed8d1abb736adc064"><td class="memTemplItemLeft" align="right" valign="top">oss_wr&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (oss_wr &amp;&amp;lhs, T rhs)</td></tr>
<tr class="separator:a56abb51f6a9aec9ed8d1abb736adc064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65859efc090932630d14b226b9c9624"><td class="memItemLeft" align="right" valign="top">detail::match_helper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ad65859efc090932630d14b226b9c9624">match</a> (<a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:ad65859efc090932630d14b226b9c9624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression.  <a href="#ad65859efc090932630d14b226b9c9624">More...</a><br/></td></tr>
<tr class="separator:ad65859efc090932630d14b226b9c9624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa18a8117e9022caea2b0606c11ebbc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adaa18a8117e9022caea2b0606c11ebbc"><td class="memTemplItemLeft" align="right" valign="top">detail::match_helper&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#adaa18a8117e9022caea2b0606c11ebbc">match</a> (T &amp;&amp;what)</td></tr>
<tr class="memdesc:adaa18a8117e9022caea2b0606c11ebbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression.  <a href="#adaa18a8117e9022caea2b0606c11ebbc">More...</a><br/></td></tr>
<tr class="separator:adaa18a8117e9022caea2b0606c11ebbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512c996a6bbaef4f7127218b5513226f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a512c996a6bbaef4f7127218b5513226f"></a>
detail::match_helper&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a512c996a6bbaef4f7127218b5513226f">match_split</a> (const std::string &amp;str, char delim, bool keep_empties=false)</td></tr>
<tr class="memdesc:a512c996a6bbaef4f7127218b5513226f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits <code>str</code> using <code>delim</code> and match the resulting strings. <br/></td></tr>
<tr class="separator:a512c996a6bbaef4f7127218b5513226f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0e5c70506e72b5f24d9fbb6dcc3c81"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:abe0e5c70506e72b5f24d9fbb6dcc3c81"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#abe0e5c70506e72b5f24d9fbb6dcc3c81">match_each</a> (InputIterator first, InputIterator last) -&gt; detail::match_each_helper&lt; InputIterator &gt;</td></tr>
<tr class="memdesc:abe0e5c70506e72b5f24d9fbb6dcc3c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression that matches each element in range [first, last).  <a href="#abe0e5c70506e72b5f24d9fbb6dcc3c81">More...</a><br/></td></tr>
<tr class="separator:abe0e5c70506e72b5f24d9fbb6dcc3c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae71367202afc39f91c6a3bb0337ba37"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Projection &gt; </td></tr>
<tr class="memitem:aae71367202afc39f91c6a3bb0337ba37"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aae71367202afc39f91c6a3bb0337ba37">match_each</a> (InputIterator first, InputIterator last, Projection proj) -&gt; detail::match_each_helper&lt; InputIterator, Projection &gt;</td></tr>
<tr class="memdesc:aae71367202afc39f91c6a3bb0337ba37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a match expression that matches <code>proj(i)</code> for each element <code>i</code> in range [first, last).  <a href="#aae71367202afc39f91c6a3bb0337ba37">More...</a><br/></td></tr>
<tr class="separator:aae71367202afc39f91c6a3bb0337ba37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab745b512aa1456c0516eb545814731a9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab745b512aa1456c0516eb545814731a9"></a>
template&lt;typename InputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ab745b512aa1456c0516eb545814731a9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_for</b> (InputIterator first, Predicate pred) -&gt; detail::match_for_helper&lt; InputIterator, Predicate &gt;</td></tr>
<tr class="separator:ab745b512aa1456c0516eb545814731a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4fcfa14fe0933d237f3d4725d640f0"><td class="memTemplParams" colspan="2"><a class="anchor" id="afc4fcfa14fe0933d237f3d4725d640f0"></a>
template&lt;typename InputIterator , typename Predicate , typename Advance &gt; </td></tr>
<tr class="memitem:afc4fcfa14fe0933d237f3d4725d640f0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_for</b> (InputIterator first, Predicate pred, Advance adv) -&gt; detail::match_for_helper&lt; InputIterator, Predicate, Advance &gt;</td></tr>
<tr class="separator:afc4fcfa14fe0933d237f3d4725d640f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda14ac66645a88a4cc58e121f941cca"><td class="memTemplParams" colspan="2"><a class="anchor" id="adda14ac66645a88a4cc58e121f941cca"></a>
template&lt;class InputIterator , class Predicate , class Advance , class Projection &gt; </td></tr>
<tr class="memitem:adda14ac66645a88a4cc58e121f941cca"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_for</b> (InputIterator first, Predicate pred, Advance adv, Projection pj) -&gt; detail::match_for_helper&lt; InputIterator, Predicate, Advance, Projection &gt;</td></tr>
<tr class="separator:adda14ac66645a88a4cc58e121f941cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1f7de88c500126cd7626401724d10b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9e1f7de88c500126cd7626401724d10b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e1f7de88c500126cd7626401724d10b"><td class="memTemplItemLeft" align="right" valign="top">detail::stream_matcher&lt; T, <br class="typebreak"/>
std::istream_iterator&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_stream</b> (std::istream &amp;stream)</td></tr>
<tr class="separator:a9e1f7de88c500126cd7626401724d10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e87041ae91c323107ec8a2cc269762"><td class="memTemplParams" colspan="2"><a class="anchor" id="a92e87041ae91c323107ec8a2cc269762"></a>
template&lt;typename T , typename InputIterator &gt; </td></tr>
<tr class="memitem:a92e87041ae91c323107ec8a2cc269762"><td class="memTemplItemLeft" align="right" valign="top">detail::stream_matcher&lt; T, <br class="typebreak"/>
InputIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_stream</b> (InputIterator first, InputIterator last)</td></tr>
<tr class="separator:a92e87041ae91c323107ec8a2cc269762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e82d1da242e60543ad44835a7e79cb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a99e82d1da242e60543ad44835a7e79cb"></a>
template&lt;typename... Lhs, typename... Rhs&gt; </td></tr>
<tr class="memitem:a99e82d1da242e60543ad44835a7e79cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Lhs..., Rhs...&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator,</b> (const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Lhs...&gt; &amp;lhs, const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Rhs...&gt; &amp;rhs)</td></tr>
<tr class="separator:a99e82d1da242e60543ad44835a7e79cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909d6f63fb7e39d1b66679d4585e71eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a909d6f63fb7e39d1b66679d4585e71eb"></a>
template&lt;typename... Cs&gt; </td></tr>
<tr class="memitem:a909d6f63fb7e39d1b66679d4585e71eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (<a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;arg)</td></tr>
<tr class="separator:a909d6f63fb7e39d1b66679d4585e71eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ceb36fc3f2adc25b284b702d30e14eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ceb36fc3f2adc25b284b702d30e14eb"></a>
template&lt;typename... Cs&gt; </td></tr>
<tr class="memitem:a8ceb36fc3f2adc25b284b702d30e14eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (<a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&amp;arg)</td></tr>
<tr class="separator:a8ceb36fc3f2adc25b284b702d30e14eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28515cdabde2f2a8d4cb6d342fb68477"><td class="memTemplParams" colspan="2"><a class="anchor" id="a28515cdabde2f2a8d4cb6d342fb68477"></a>
template&lt;typename... Cs&gt; </td></tr>
<tr class="memitem:a28515cdabde2f2a8d4cb6d342fb68477"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (const <a class="el" href="classcppa_1_1match__expr.html">match_expr</a>&lt; Cs...&gt; &amp;arg)</td></tr>
<tr class="separator:a28515cdabde2f2a8d4cb6d342fb68477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f17df0c43239b3ad2c7aa794ff1616c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8f17df0c43239b3ad2c7aa794ff1616c"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a8f17df0c43239b3ad2c7aa794ff1616c"><td class="memTemplItemLeft" align="right" valign="top">match_expr_from_type_list<br class="typebreak"/>
&lt; typename <a class="el" href="structcppa_1_1util_1_1tl__concat.html">util::tl_concat</a><br class="typebreak"/>
&lt; typename T::cases_list, <br class="typebreak"/>
typename Ts::cases_list... &gt;<br class="typebreak"/>
::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_collect</b> (const T &amp;arg, const Ts &amp;...args)</td></tr>
<tr class="separator:a8f17df0c43239b3ad2c7aa794ff1616c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15c62d1f2083756252c0fafef92f900"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad15c62d1f2083756252c0fafef92f900"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcppa_1_1message__header.html">message_header</a> &amp;lhs, const <a class="el" href="classcppa_1_1message__header.html">message_header</a> &amp;rhs)</td></tr>
<tr class="separator:ad15c62d1f2083756252c0fafef92f900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529d4d702ab15d36e5181ae7d6be478d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a529d4d702ab15d36e5181ae7d6be478d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcppa_1_1message__header.html">message_header</a> &amp;lhs, const <a class="el" href="classcppa_1_1message__header.html">message_header</a> &amp;rhs)</td></tr>
<tr class="separator:a529d4d702ab15d36e5181ae7d6be478d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e103f83664c764b44799700daa1e83e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e103f83664c764b44799700daa1e83e"></a>
const <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>uniform_typeid</b> (const std::type_info &amp;)</td></tr>
<tr class="separator:a9e103f83664c764b44799700daa1e83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d771014d43e74ef4e17073bebaa2ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1d771014d43e74ef4e17073bebaa2ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classcppa_1_1uniform__type__info.html">uniform_type_info</a> &amp;lhs, const std::type_info &amp;rhs)</td></tr>
<tr class="separator:ac1d771014d43e74ef4e17073bebaa2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccfef6633740c1eff30d983dcfba54f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeccfef6633740c1eff30d983dcfba54f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classcppa_1_1object.html">object</a> &amp;lhs, const <a class="el" href="classcppa_1_1object.html">object</a> &amp;rhs)</td></tr>
<tr class="separator:aeccfef6633740c1eff30d983dcfba54f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4d0a97a3d502f72511ea3464db9e13"><td class="memTemplParams" colspan="2"><a class="anchor" id="afc4d0a97a3d502f72511ea3464db9e13"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc4d0a97a3d502f72511ea3464db9e13"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (<a class="el" href="classcppa_1_1object.html">object</a> &amp;obj)</td></tr>
<tr class="separator:afc4d0a97a3d502f72511ea3464db9e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafac7c509fc9734cffbf3608e64a04b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="aafac7c509fc9734cffbf3608e64a04b5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafac7c509fc9734cffbf3608e64a04b5"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="classcppa_1_1object.html">object</a> &amp;obj)</td></tr>
<tr class="separator:aafac7c509fc9734cffbf3608e64a04b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af928936d573122345bc0737615f95f33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af928936d573122345bc0737615f95f33"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#af928936d573122345bc0737615f95f33">val</a> ()</td></tr>
<tr class="memdesc:af928936d573122345bc0737615f95f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches any value of type <code>T</code>.  <a href="#af928936d573122345bc0737615f95f33">More...</a><br/></td></tr>
<tr class="separator:af928936d573122345bc0737615f95f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d0d9e15f20fe8a0644a1d137d27e90"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a25d0d9e15f20fe8a0644a1d137d27e90"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a25d0d9e15f20fe8a0644a1d137d27e90">on</a> (const T &amp;arg, const Ts &amp;...args)</td></tr>
<tr class="memdesc:a25d0d9e15f20fe8a0644a1d137d27e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches values.  <a href="#a25d0d9e15f20fe8a0644a1d137d27e90">More...</a><br/></td></tr>
<tr class="separator:a25d0d9e15f20fe8a0644a1d137d27e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8c5c063a1758690748e20c805a76aa"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:acb8c5c063a1758690748e20c805a76aa"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#acb8c5c063a1758690748e20c805a76aa">on</a> ()</td></tr>
<tr class="memdesc:acb8c5c063a1758690748e20c805a76aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches types.  <a href="#acb8c5c063a1758690748e20c805a76aa">More...</a><br/></td></tr>
<tr class="separator:acb8c5c063a1758690748e20c805a76aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1341cd8bd16f4821146053de1093a732"><td class="memTemplParams" colspan="2">template&lt;atom_value... Atoms, typename... Ts&gt; </td></tr>
<tr class="memitem:a1341cd8bd16f4821146053de1093a732"><td class="memTemplItemLeft" align="right" valign="top">__unspecified__&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a1341cd8bd16f4821146053de1093a732">on</a> ()</td></tr>
<tr class="memdesc:a1341cd8bd16f4821146053de1093a732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression that matches types.  <a href="#a1341cd8bd16f4821146053de1093a732">More...</a><br/></td></tr>
<tr class="separator:a1341cd8bd16f4821146053de1093a732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5874085dfe88492adbc380b55c77053f"><td class="memTemplParams" colspan="2">template&lt;typename Signature , typename... Ts&gt; </td></tr>
<tr class="memitem:a5874085dfe88492adbc380b55c77053f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5874085dfe88492adbc380b55c77053f">spawn_cl</a> (const <a class="el" href="classcppa_1_1opencl_1_1program.html">opencl::program</a> &amp;prog, const char *fname, const <a class="el" href="namespacecppa_1_1opencl.html#a29fc02750633596e298f8ab543b21152">opencl::dim_vec</a> &amp;dims, const <a class="el" href="namespacecppa_1_1opencl.html#a29fc02750633596e298f8ab543b21152">opencl::dim_vec</a> &amp;offset={}, const <a class="el" href="namespacecppa_1_1opencl.html#a29fc02750633596e298f8ab543b21152">opencl::dim_vec</a> &amp;local_dims={})</td></tr>
<tr class="memdesc:a5874085dfe88492adbc380b55c77053f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code> from <code>prog</code>.  <a href="#a5874085dfe88492adbc380b55c77053f">More...</a><br/></td></tr>
<tr class="separator:a5874085dfe88492adbc380b55c77053f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733d5a4394026abf6ddaba265f6970e8"><td class="memTemplParams" colspan="2">template&lt;typename Signature , typename... Ts&gt; </td></tr>
<tr class="memitem:a733d5a4394026abf6ddaba265f6970e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a733d5a4394026abf6ddaba265f6970e8">spawn_cl</a> (const char *source, const char *fname, const <a class="el" href="namespacecppa_1_1opencl.html#a29fc02750633596e298f8ab543b21152">opencl::dim_vec</a> &amp;dims, const <a class="el" href="namespacecppa_1_1opencl.html#a29fc02750633596e298f8ab543b21152">opencl::dim_vec</a> &amp;offset={}, const <a class="el" href="namespacecppa_1_1opencl.html#a29fc02750633596e298f8ab543b21152">opencl::dim_vec</a> &amp;local_dims={})</td></tr>
<tr class="memdesc:a733d5a4394026abf6ddaba265f6970e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles <code>source</code> and creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code>.  <a href="#a733d5a4394026abf6ddaba265f6970e8">More...</a><br/></td></tr>
<tr class="separator:a733d5a4394026abf6ddaba265f6970e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7ec2cc77f30d3921a26fa21b902075"><td class="memTemplParams" colspan="2">template&lt;typename MapArgs , typename MapResult &gt; </td></tr>
<tr class="memitem:a7d7ec2cc77f30d3921a26fa21b902075"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a7d7ec2cc77f30d3921a26fa21b902075">spawn_cl</a> (const <a class="el" href="classcppa_1_1opencl_1_1program.html">opencl::program</a> &amp;prog, const char *fname, MapArgs map_args, MapResult map_result, const <a class="el" href="namespacecppa_1_1opencl.html#a29fc02750633596e298f8ab543b21152">opencl::dim_vec</a> &amp;dims, const <a class="el" href="namespacecppa_1_1opencl.html#a29fc02750633596e298f8ab543b21152">opencl::dim_vec</a> &amp;offset={}, const <a class="el" href="namespacecppa_1_1opencl.html#a29fc02750633596e298f8ab543b21152">opencl::dim_vec</a> &amp;local_dims={})</td></tr>
<tr class="memdesc:a7d7ec2cc77f30d3921a26fa21b902075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code> from <code>prog</code>, using <code>map_args</code> to extract the function arguments from incoming messages and <code>map_result</code> to transform the result before sending it as response.  <a href="#a7d7ec2cc77f30d3921a26fa21b902075">More...</a><br/></td></tr>
<tr class="separator:a7d7ec2cc77f30d3921a26fa21b902075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91e347999ca21eaf734024e45eff768"><td class="memTemplParams" colspan="2">template&lt;typename MapArgs , typename MapResult &gt; </td></tr>
<tr class="memitem:ae91e347999ca21eaf734024e45eff768"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ae91e347999ca21eaf734024e45eff768">spawn_cl</a> (const char *source, const char *fun_name, MapArgs map_args, MapResult map_result, const <a class="el" href="namespacecppa_1_1opencl.html#a29fc02750633596e298f8ab543b21152">opencl::dim_vec</a> &amp;dims, const <a class="el" href="namespacecppa_1_1opencl.html#a29fc02750633596e298f8ab543b21152">opencl::dim_vec</a> &amp;offset={}, const <a class="el" href="namespacecppa_1_1opencl.html#a29fc02750633596e298f8ab543b21152">opencl::dim_vec</a> &amp;local_dims={})</td></tr>
<tr class="memdesc:ae91e347999ca21eaf734024e45eff768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compiles <code>source</code> and creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code>, using <code>map_args</code> to extract the function arguments from incoming messages and <code>map_result</code> to transform the result before sending it as response.  <a href="#ae91e347999ca21eaf734024e45eff768">More...</a><br/></td></tr>
<tr class="separator:ae91e347999ca21eaf734024e45eff768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203490e67e091f123d0cc6f7884e88c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a203490e67e091f123d0cc6f7884e88c9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a203490e67e091f123d0cc6f7884e88c9"><td class="memTemplItemLeft" align="right" valign="top">detail::rd_arg_functor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a203490e67e091f123d0cc6f7884e88c9">rd_arg</a> (T &amp;storage)</td></tr>
<tr class="memdesc:a203490e67e091f123d0cc6f7884e88c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-hand side of a match expression for a program option reading an argument of type <code>T</code>. <br/></td></tr>
<tr class="separator:a203490e67e091f123d0cc6f7884e88c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ebc36e2bddc5cef48f1688af4d7608"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab1ebc36e2bddc5cef48f1688af4d7608"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1ebc36e2bddc5cef48f1688af4d7608"><td class="memTemplItemLeft" align="right" valign="top">detail::add_arg_functor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ab1ebc36e2bddc5cef48f1688af4d7608">add_arg</a> (std::vector&lt; T &gt; &amp;storage)</td></tr>
<tr class="memdesc:ab1ebc36e2bddc5cef48f1688af4d7608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-hand side of a match expression for a program option adding an argument of type <code>T</code> to <code>storage</code>. <br/></td></tr>
<tr class="separator:ab1ebc36e2bddc5cef48f1688af4d7608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccdbd7a582b0e63258548e836f00c9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ccdbd7a582b0e63258548e836f00c9a"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>set_flag</b> (bool &amp;storage)</td></tr>
<tr class="separator:a6ccdbd7a582b0e63258548e836f00c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e2e610b7d676a86b43b7b5552ea3e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6e2e610b7d676a86b43b7b5552ea3e9"></a>
detail::opt1_rvalue_builder&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ac6e2e610b7d676a86b43b7b5552ea3e9">on_opt1</a> (char short_opt, std::string long_opt, <a class="el" href="namespacecppa.html#ab8969803d282c6f1fe9b7641cd9357cf">options_description</a> *desc=nullptr, std::string help_text=&quot;&quot;, std::string help_group=&quot;general options&quot;)</td></tr>
<tr class="memdesc:ac6e2e610b7d676a86b43b7b5552ea3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a match expression for a program option with one argument. <br/></td></tr>
<tr class="separator:ac6e2e610b7d676a86b43b7b5552ea3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbb3d478cab709c2eeae7146d73f24c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bbb3d478cab709c2eeae7146d73f24c"></a>
detail::opt0_rvalue_builder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5bbb3d478cab709c2eeae7146d73f24c">on_opt0</a> (char short_opt, std::string long_opt, <a class="el" href="namespacecppa.html#ab8969803d282c6f1fe9b7641cd9357cf">options_description</a> *desc=nullptr, std::string help_text=&quot;&quot;, std::string help_group=&quot;general options&quot;)</td></tr>
<tr class="memdesc:a5bbb3d478cab709c2eeae7146d73f24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a match expression for a program option with no argument. <br/></td></tr>
<tr class="separator:a5bbb3d478cab709c2eeae7146d73f24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9f8e43fb78f1a6c9afb6700ebe4404"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e9f8e43fb78f1a6c9afb6700ebe4404"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a3e9f8e43fb78f1a6c9afb6700ebe4404">print_desc</a> (<a class="el" href="namespacecppa.html#ab8969803d282c6f1fe9b7641cd9357cf">options_description</a> *desc, std::ostream &amp;out=std::cout)</td></tr>
<tr class="memdesc:a3e9f8e43fb78f1a6c9afb6700ebe4404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function that prints the help text of <code>desc</code> to <code>out</code>. <br/></td></tr>
<tr class="separator:a3e9f8e43fb78f1a6c9afb6700ebe4404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2216fa186264747a6256d0d21dbf98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb2216fa186264747a6256d0d21dbf98"></a>
std::function&lt; void()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aeb2216fa186264747a6256d0d21dbf98">print_desc_and_exit</a> (<a class="el" href="namespacecppa.html#ab8969803d282c6f1fe9b7641cd9357cf">options_description</a> *desc, std::ostream &amp;out=std::cout, int exit_reason=0)</td></tr>
<tr class="memdesc:aeb2216fa186264747a6256d0d21dbf98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function that prints the help text of <code>desc</code> to <code>out</code> and then calls <code>exit(exit_reason)</code>. <br/></td></tr>
<tr class="separator:aeb2216fa186264747a6256d0d21dbf98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40268c41a4ec8eda4ff9980f91f9add"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab40268c41a4ec8eda4ff9980f91f9add"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab40268c41a4ec8eda4ff9980f91f9add"><td class="memTemplItemLeft" align="right" valign="top">std::conditional<br class="typebreak"/>
&lt; T::may_have_timeout, <br class="typebreak"/>
<a class="el" href="classcppa_1_1behavior.html">behavior</a>, <a class="el" href="classcppa_1_1partial__function.html">partial_function</a> &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_convert</b> (const T &amp;arg)</td></tr>
<tr class="separator:ab40268c41a4ec8eda4ff9980f91f9add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0346c0284061a4c26dd488dc0bf1fc1f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0346c0284061a4c26dd488dc0bf1fc1f"></a>
template&lt;typename T0 , typename T1 , typename... Ts&gt; </td></tr>
<tr class="memitem:a0346c0284061a4c26dd488dc0bf1fc1f"><td class="memTemplItemLeft" align="right" valign="top">std::conditional<br class="typebreak"/>
&lt; util::disjunction<br class="typebreak"/>
&lt; T0::may_have_timeout, <br class="typebreak"/>
T1::may_have_timeout, <br class="typebreak"/>
Ts::may_have_timeout... &gt;<br class="typebreak"/>
::value, <a class="el" href="classcppa_1_1behavior.html">behavior</a>, <br class="typebreak"/>
<a class="el" href="classcppa_1_1partial__function.html">partial_function</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>match_expr_convert</b> (const T0 &amp;arg0, const T1 &amp;arg1, const Ts &amp;...args)</td></tr>
<tr class="separator:a0346c0284061a4c26dd488dc0bf1fc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d1de7bc77d88156d0e12e373ab2c613"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___type_system.html#ga5d1de7bc77d88156d0e12e373ab2c613">primitive_type_name</a> (<a class="el" href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899">primitive_type</a> ptype)</td></tr>
<tr class="memdesc:ga5d1de7bc77d88156d0e12e373ab2c613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a <a class="el" href="group___type_system.html#ga4405c08180f3db0936dcc6afe84f2899" title="Represents the type flag of primitive_variant.">primitive_type</a> value to its name.  <a href="group___type_system.html#ga5d1de7bc77d88156d0e12e373ab2c613">More...</a><br/></td></tr>
<tr class="separator:ga5d1de7bc77d88156d0e12e373ab2c613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f48cc1f5e2597c4a131d292145f728f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f48cc1f5e2597c4a131d292145f728f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f48cc1f5e2597c4a131d292145f728f"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a> &amp;pv)</td></tr>
<tr class="separator:a1f48cc1f5e2597c4a131d292145f728f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7eeed8ed3edc2558cf01f26bf86691"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeb7eeed8ed3edc2558cf01f26bf86691"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb7eeed8ed3edc2558cf01f26bf86691"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_ref</b> (<a class="el" href="classcppa_1_1primitive__variant.html">primitive_variant</a> &amp;pv)</td></tr>
<tr class="separator:aeb7eeed8ed3edc2558cf01f26bf86691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ad36edc791ad88439e6b1d30e9ea14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00ad36edc791ad88439e6b1d30e9ea14"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>node_id_from_string</b> (const std::string &amp;hash, <a class="el" href="classcppa_1_1process__information.html#ab9a871d7dff99b789b7b44cb67480d9d">process_information::node_id_type</a> &amp;node_id)</td></tr>
<tr class="separator:a00ad36edc791ad88439e6b1d30e9ea14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da650abe0612dd640f67af532373440"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6da650abe0612dd640f67af532373440"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal</b> (const std::string &amp;hash, const <a class="el" href="classcppa_1_1process__information.html#ab9a871d7dff99b789b7b44cb67480d9d">process_information::node_id_type</a> &amp;node_id)</td></tr>
<tr class="separator:a6da650abe0612dd640f67af532373440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fadf880997152157b01eb708534fe09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fadf880997152157b01eb708534fe09"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal</b> (const <a class="el" href="classcppa_1_1process__information.html#ab9a871d7dff99b789b7b44cb67480d9d">process_information::node_id_type</a> &amp;node_id, const std::string &amp;hash)</td></tr>
<tr class="separator:a9fadf880997152157b01eb708534fe09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b764d3d88909554ba09e0b7942ac1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0b764d3d88909554ba09e0b7942ac1b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>receive_loop</b> (<a class="el" href="classcppa_1_1behavior.html">behavior</a> rules)</td></tr>
<tr class="separator:af0b764d3d88909554ba09e0b7942ac1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd959a7ff3c017ded6b64ee72dcec97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9fd959a7ff3c017ded6b64ee72dcec97">set_scheduler</a> (<a class="el" href="classcppa_1_1scheduler.html">scheduler</a> *sched)</td></tr>
<tr class="memdesc:a9fd959a7ff3c017ded6b64ee72dcec97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scheduler to <code>sched</code>.  <a href="#a9fd959a7ff3c017ded6b64ee72dcec97">More...</a><br/></td></tr>
<tr class="separator:a9fd959a7ff3c017ded6b64ee72dcec97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2a11054c90870f7f7bae3117845127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a8f2a11054c90870f7f7bae3117845127">set_default_scheduler</a> (size_t num_threads)</td></tr>
<tr class="memdesc:a8f2a11054c90870f7f7bae3117845127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a thread pool scheduler with <code>num_threads</code> worker threads.  <a href="#a8f2a11054c90870f7f7bae3117845127">More...</a><br/></td></tr>
<tr class="separator:a8f2a11054c90870f7f7bae3117845127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090fbee59721028912f07709e6ac8882"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a090fbee59721028912f07709e6ac8882"></a>
logging *&#160;</td><td class="memItemRight" valign="bottom"><b>get_logger</b> ()</td></tr>
<tr class="separator:a090fbee59721028912f07709e6ac8882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438040c204e8dc7819cd7ca9bd661eec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a438040c204e8dc7819cd7ca9bd661eec"></a>
<a class="el" href="classcppa_1_1scheduler.html">scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_scheduler</b> ()</td></tr>
<tr class="separator:a438040c204e8dc7819cd7ca9bd661eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7767f4842534d531923125cb8f06d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c7767f4842534d531923125cb8f06d9"></a>
detail::group_manager *&#160;</td><td class="memItemRight" valign="bottom"><b>get_group_manager</b> ()</td></tr>
<tr class="separator:a8c7767f4842534d531923125cb8f06d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1761ff3671f8270518ebce7f025db448"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1761ff3671f8270518ebce7f025db448"></a>
detail::actor_registry *&#160;</td><td class="memItemRight" valign="bottom"><b>get_actor_registry</b> ()</td></tr>
<tr class="separator:a1761ff3671f8270518ebce7f025db448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363b4388d789e30c8e12642e01f36f5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a363b4388d789e30c8e12642e01f36f5e"></a>
<a class="el" href="classcppa_1_1network_1_1middleman.html">network::middleman</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_middleman</b> ()</td></tr>
<tr class="separator:a363b4388d789e30c8e12642e01f36f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb30b478f6a94f90dc672d718160781"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eb30b478f6a94f90dc672d718160781"></a>
detail::uniform_type_info_map *&#160;</td><td class="memItemRight" valign="bottom"><b>get_uniform_type_info_map</b> ()</td></tr>
<tr class="separator:a6eb30b478f6a94f90dc672d718160781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef56ad712e7f872723ccf0e992c2095"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ef56ad712e7f872723ccf0e992c2095"></a>
detail::abstract_tuple *&#160;</td><td class="memItemRight" valign="bottom"><b>get_tuple_dummy</b> ()</td></tr>
<tr class="separator:a9ef56ad712e7f872723ccf0e992c2095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3c155b29caab8bf8a461b751eec4be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b3c155b29caab8bf8a461b751eec4be"></a>
detail::empty_tuple *&#160;</td><td class="memItemRight" valign="bottom"><b>get_empty_tuple</b> ()</td></tr>
<tr class="separator:a7b3c155b29caab8bf8a461b751eec4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a28e93004ce87aa330248e4a5604ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58a28e93004ce87aa330248e4a5604ec"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> &amp;what)</td></tr>
<tr class="separator:a58a28e93004ce87aa330248e4a5604ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55814e02519b1cb77284a869b0dc1ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac55814e02519b1cb77284a869b0dc1ac"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1message__header.html">message_header</a> &amp;what)</td></tr>
<tr class="separator:ac55814e02519b1cb77284a869b0dc1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dafe56a214fb056845a07e3b884ca7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5dafe56a214fb056845a07e3b884ca7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> &amp;what)</td></tr>
<tr class="separator:ab5dafe56a214fb056845a07e3b884ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb757fb5458e2f5824fb6a0ee1b48092"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb757fb5458e2f5824fb6a0ee1b48092"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">group_ptr</a> &amp;what)</td></tr>
<tr class="separator:aeb757fb5458e2f5824fb6a0ee1b48092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e006c238ecdc980569af6c05828772"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17e006c238ecdc980569af6c05828772"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">channel_ptr</a> &amp;what)</td></tr>
<tr class="separator:a17e006c238ecdc980569af6c05828772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb103c782d4dd432e52f51e247743c3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb103c782d4dd432e52f51e247743c3f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1process__information.html">process_information</a> &amp;what)</td></tr>
<tr class="separator:afb103c782d4dd432e52f51e247743c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c07fee8995c064a3dc80378ba9911df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c07fee8995c064a3dc80378ba9911df"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const process_information_ptr &amp;what)</td></tr>
<tr class="separator:a2c07fee8995c064a3dc80378ba9911df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7919488dad32bd35a6e461f4ae6d0bd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7919488dad32bd35a6e461f4ae6d0bd7"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const <a class="el" href="classcppa_1_1object.html">object</a> &amp;what)</td></tr>
<tr class="separator:a7919488dad32bd35a6e461f4ae6d0bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60aae38fbd2f412089646134bbb5c75f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60aae38fbd2f412089646134bbb5c75f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a60aae38fbd2f412089646134bbb5c75f">to_verbose_string</a> (const std::exception &amp;e)</td></tr>
<tr class="memdesc:a60aae38fbd2f412089646134bbb5c75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code>e</code> to a string including the demangled type of e and <code>e.what()</code>. <br/></td></tr>
<tr class="separator:a60aae38fbd2f412089646134bbb5c75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33344c46529f70febab48161c0c53a68"><td class="memTemplParams" colspan="2">template&lt;typename Types &gt; </td></tr>
<tr class="memitem:a33344c46529f70febab48161c0c53a68"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecppa.html#a5ab63f2274711ea5cce959c91d793b25">wildcard_position</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a33344c46529f70febab48161c0c53a68">get_wildcard_position</a> ()</td></tr>
<tr class="memdesc:a33344c46529f70febab48161c0c53a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position of <a class="el" href="structcppa_1_1anything.html">anything</a> from the type list <code>Types</code>.  <a href="#a33344c46529f70febab48161c0c53a68">More...</a><br/></td></tr>
<tr class="separator:a33344c46529f70febab48161c0c53a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga93044b55ecb23a88effc918eb8a36eca"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:ga93044b55ecb23a88effc918eb8a36eca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecppa.html#a7838b52eb8d3c16d562e44f5b89629a4">enable_if_channel</a>&lt; C, const <br class="typebreak"/>
<a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; C &gt; &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga93044b55ecb23a88effc918eb8a36eca">operator&lt;&lt;</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; C &gt; &amp;whom, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:ga93044b55ecb23a88effc918eb8a36eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to <code>whom</code>.  <a href="group___message_handling.html#ga93044b55ecb23a88effc918eb8a36eca">More...</a><br/></td></tr>
<tr class="separator:ga93044b55ecb23a88effc918eb8a36eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9832d0c878b8e8635c7d5f23220a1b0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9832d0c878b8e8635c7d5f23220a1b0f"></a>
const self_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const self_type &amp;s, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="separator:ga9832d0c878b8e8635c7d5f23220a1b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga64b99980b69ba8e8cdd218e402f48fd6"><td class="memTemplParams" colspan="2">template&lt;spawn_options Options = no_spawn_options, typename... Ts&gt; </td></tr>
<tr class="memitem:ga64b99980b69ba8e8cdd218e402f48fd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#ga64b99980b69ba8e8cdd218e402f48fd6">spawn</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga64b99980b69ba8e8cdd218e402f48fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new <a class="el" href="classcppa_1_1actor.html">actor</a> that evaluates given arguments.  <a href="group___actor_creation.html#ga64b99980b69ba8e8cdd218e402f48fd6">More...</a><br/></td></tr>
<tr class="separator:ga64b99980b69ba8e8cdd218e402f48fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0ea633de5e468cacd5156d014b7c647"><td class="memTemplParams" colspan="2">template&lt;class Impl , spawn_options Options = no_spawn_options, typename... Ts&gt; </td></tr>
<tr class="memitem:gae0ea633de5e468cacd5156d014b7c647"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gae0ea633de5e468cacd5156d014b7c647">spawn</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:gae0ea633de5e468cacd5156d014b7c647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns an actor of type <code>Impl</code>.  <a href="group___actor_creation.html#gae0ea633de5e468cacd5156d014b7c647">More...</a><br/></td></tr>
<tr class="separator:gae0ea633de5e468cacd5156d014b7c647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72975ef0dee3891fb56c195c0a75fc2b"><td class="memTemplParams" colspan="2">template&lt;spawn_options Options = no_spawn_options, typename... Ts&gt; </td></tr>
<tr class="memitem:ga72975ef0dee3891fb56c195c0a75fc2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#ga72975ef0dee3891fb56c195c0a75fc2b">spawn_in_group</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">group_ptr</a> &amp;grp, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga72975ef0dee3891fb56c195c0a75fc2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns a new actor that evaluates given arguments and immediately joins <code>grp</code>.  <a href="group___actor_creation.html#ga72975ef0dee3891fb56c195c0a75fc2b">More...</a><br/></td></tr>
<tr class="separator:ga72975ef0dee3891fb56c195c0a75fc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfc41ffbe46b4e47a4a6955e4fe0c6e3"><td class="memTemplParams" colspan="2">template&lt;class Impl , spawn_options Options = no_spawn_options, typename... Ts&gt; </td></tr>
<tr class="memitem:gacfc41ffbe46b4e47a4a6955e4fe0c6e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___actor_creation.html#gacfc41ffbe46b4e47a4a6955e4fe0c6e3">spawn_in_group</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">group_ptr</a> &amp;grp, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:gacfc41ffbe46b4e47a4a6955e4fe0c6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawns an actor of type <code>Impl</code> that immediately joins <code>grp</code>.  <a href="group___actor_creation.html#gacfc41ffbe46b4e47a4a6955e4fe0c6e3">More...</a><br/></td></tr>
<tr class="separator:gacfc41ffbe46b4e47a4a6955e4fe0c6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga2572278151133dc5aea4ef57f15ba79a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2572278151133dc5aea4ef57f15ba79a"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga2572278151133dc5aea4ef57f15ba79a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___blocking_a_p_i.html#ga2572278151133dc5aea4ef57f15ba79a">receive</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga2572278151133dc5aea4ef57f15ba79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues the next message from the mailbox that is matched by given behavior. <br/></td></tr>
<tr class="separator:ga2572278151133dc5aea4ef57f15ba79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4dd7ae464477ee09420f3db58803806"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa4dd7ae464477ee09420f3db58803806"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gaa4dd7ae464477ee09420f3db58803806"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___blocking_a_p_i.html#gaa4dd7ae464477ee09420f3db58803806">receive_loop</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:gaa4dd7ae464477ee09420f3db58803806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives messages in an endless loop. Semantically equal to: <code>for (;;) { receive(...); }</code> <br/></td></tr>
<tr class="separator:gaa4dd7ae464477ee09420f3db58803806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c02896ff6b0ca3a36829fbe1482584"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac8c02896ff6b0ca3a36829fbe1482584"><td class="memTemplItemLeft" align="right" valign="top">detail::receive_for_helper&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___blocking_a_p_i.html#gac8c02896ff6b0ca3a36829fbe1482584">receive_for</a> (T &amp;begin, const T &amp;end)</td></tr>
<tr class="memdesc:gac8c02896ff6b0ca3a36829fbe1482584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives messages as in a range-based loop.  <a href="group___blocking_a_p_i.html#gac8c02896ff6b0ca3a36829fbe1482584">More...</a><br/></td></tr>
<tr class="separator:gac8c02896ff6b0ca3a36829fbe1482584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7410ca248936f055cdf10d90694af732"><td class="memTemplParams" colspan="2">template&lt;typename Statement &gt; </td></tr>
<tr class="memitem:ga7410ca248936f055cdf10d90694af732"><td class="memTemplItemLeft" align="right" valign="top">detail::receive_while_helper<br class="typebreak"/>
&lt; Statement &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___blocking_a_p_i.html#ga7410ca248936f055cdf10d90694af732">receive_while</a> (Statement &amp;&amp;stmt)</td></tr>
<tr class="memdesc:ga7410ca248936f055cdf10d90694af732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives messages as long as <code>stmt</code> returns true.  <a href="group___blocking_a_p_i.html#ga7410ca248936f055cdf10d90694af732">More...</a><br/></td></tr>
<tr class="separator:ga7410ca248936f055cdf10d90694af732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a52e24a04a2e4cb0d5de312b94b4c8"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga32a52e24a04a2e4cb0d5de312b94b4c8"><td class="memTemplItemLeft" align="right" valign="top">detail::do_receive_helper&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___blocking_a_p_i.html#ga32a52e24a04a2e4cb0d5de312b94b4c8">do_receive</a> (Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga32a52e24a04a2e4cb0d5de312b94b4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives messages until <code>stmt</code> returns true.  <a href="group___blocking_a_p_i.html#ga32a52e24a04a2e4cb0d5de312b94b4c8">More...</a><br/></td></tr>
<tr class="separator:ga32a52e24a04a2e4cb0d5de312b94b4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af7baef989d6717c613fb4205b730bce2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7baef989d6717c613fb4205b730bce2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#af7baef989d6717c613fb4205b730bce2">send_tuple</a> (destination_header hdr, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:af7baef989d6717c613fb4205b730bce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>what</code> to the receiver specified in <code>hdr</code>. <br/></td></tr>
<tr class="separator:af7baef989d6717c613fb4205b730bce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6af8d3fa6a39b766cac672c1ffcdf3"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:aef6af8d3fa6a39b766cac672c1ffcdf3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aef6af8d3fa6a39b766cac672c1ffcdf3">send</a> (destination_header hdr, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:aef6af8d3fa6a39b766cac672c1ffcdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>{what...}</code> to the receiver specified in <code>hdr</code>.  <a href="#aef6af8d3fa6a39b766cac672c1ffcdf3">More...</a><br/></td></tr>
<tr class="separator:aef6af8d3fa6a39b766cac672c1ffcdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912d4174c1f9fec79cc4d21e9ad44fa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a912d4174c1f9fec79cc4d21e9ad44fa0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a912d4174c1f9fec79cc4d21e9ad44fa0">send_tuple_as</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> from, <a class="el" href="classcppa_1_1intrusive__ptr.html">channel_ptr</a> whom, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:a912d4174c1f9fec79cc4d21e9ad44fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>what</code> to <code>whom</code>, but sets the sender information to <code>from</code>. <br/></td></tr>
<tr class="separator:a912d4174c1f9fec79cc4d21e9ad44fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03105d44e4e9056086a20f83f3a13929"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a03105d44e4e9056086a20f83f3a13929"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a03105d44e4e9056086a20f83f3a13929">send_as</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> from, <a class="el" href="classcppa_1_1intrusive__ptr.html">channel_ptr</a> whom, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:a03105d44e4e9056086a20f83f3a13929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>{what...}</code> as a message to <code>whom</code>, but sets the sender information to <code>from</code>.  <a href="#a03105d44e4e9056086a20f83f3a13929">More...</a><br/></td></tr>
<tr class="separator:a03105d44e4e9056086a20f83f3a13929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a3532bd3d67147a022ba56dc08fb41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1message__future.html">message_future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a54a3532bd3d67147a022ba56dc08fb41">sync_send_tuple</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> whom, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:a54a3532bd3d67147a022ba56dc08fb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>what</code> as a synchronous message to <code>whom</code>.  <a href="#a54a3532bd3d67147a022ba56dc08fb41">More...</a><br/></td></tr>
<tr class="separator:a54a3532bd3d67147a022ba56dc08fb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833551fceb9e2aa6200c35fb710bceb0"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a833551fceb9e2aa6200c35fb710bceb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1message__future.html">message_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a833551fceb9e2aa6200c35fb710bceb0">sync_send</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> whom, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:a833551fceb9e2aa6200c35fb710bceb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>{what...}</code> as a synchronous message to <code>whom</code>.  <a href="#a833551fceb9e2aa6200c35fb710bceb0">More...</a><br/></td></tr>
<tr class="separator:a833551fceb9e2aa6200c35fb710bceb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ed65c9a5a5e983cb510e4964e1942f"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period , typename... Ts&gt; </td></tr>
<tr class="memitem:a43ed65c9a5a5e983cb510e4964e1942f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1message__future.html">message_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a43ed65c9a5a5e983cb510e4964e1942f">timed_sync_send_tuple</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> whom, const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:a43ed65c9a5a5e983cb510e4964e1942f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>what</code> as a synchronous message to <code>whom</code> with a timeout.  <a href="#a43ed65c9a5a5e983cb510e4964e1942f">More...</a><br/></td></tr>
<tr class="separator:a43ed65c9a5a5e983cb510e4964e1942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d9479bd6f3e332a216d374540294f2"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period , typename... Ts&gt; </td></tr>
<tr class="memitem:af1d9479bd6f3e332a216d374540294f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppa_1_1message__future.html">message_future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#af1d9479bd6f3e332a216d374540294f2">timed_sync_send</a> (<a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> whom, const std::chrono::duration&lt; Rep, Period &gt; &amp;rel_time, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:af1d9479bd6f3e332a216d374540294f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>{what...}</code> as a synchronous message to <code>whom</code> with a timeout.  <a href="#af1d9479bd6f3e332a216d374540294f2">More...</a><br/></td></tr>
<tr class="separator:af1d9479bd6f3e332a216d374540294f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d847736b07a78186a20cd2b25e7fa47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a4d847736b07a78186a20cd2b25e7fa47">reply_tuple</a> (<a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:a4d847736b07a78186a20cd2b25e7fa47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to the sender of the last received message.  <a href="#a4d847736b07a78186a20cd2b25e7fa47">More...</a><br/></td></tr>
<tr class="separator:a4d847736b07a78186a20cd2b25e7fa47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace432faf00fa92965f1fbe94bb8f0eae"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ace432faf00fa92965f1fbe94bb8f0eae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#ace432faf00fa92965f1fbe94bb8f0eae">reply</a> (Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:ace432faf00fa92965f1fbe94bb8f0eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to the sender of the last received message.  <a href="#ace432faf00fa92965f1fbe94bb8f0eae">More...</a><br/></td></tr>
<tr class="separator:ace432faf00fa92965f1fbe94bb8f0eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b7c1a13ac78822e3efc607b887664a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a03b7c1a13ac78822e3efc607b887664a"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a03b7c1a13ac78822e3efc607b887664a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a03b7c1a13ac78822e3efc607b887664a">reply_to</a> (const <a class="el" href="classcppa_1_1response__handle.html">response_handle</a> &amp;handle, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:a03b7c1a13ac78822e3efc607b887664a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message as reply to <code>handle</code>. <br/></td></tr>
<tr class="separator:a03b7c1a13ac78822e3efc607b887664a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4dc7aa969b618f88f0571c0b8ea3d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9a4dc7aa969b618f88f0571c0b8ea3d9">reply_tuple_to</a> (const <a class="el" href="classcppa_1_1response__handle.html">response_handle</a> &amp;handle, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:a9a4dc7aa969b618f88f0571c0b8ea3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replies with <code>what</code> to <code>handle</code>.  <a href="#a9a4dc7aa969b618f88f0571c0b8ea3d9">More...</a><br/></td></tr>
<tr class="separator:a9a4dc7aa969b618f88f0571c0b8ea3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7296666267daedec965b147f9aa1e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e7296666267daedec965b147f9aa1e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9e7296666267daedec965b147f9aa1e7">forward_to</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> &amp;whom)</td></tr>
<tr class="memdesc:a9e7296666267daedec965b147f9aa1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards the last received message to <code>whom</code>. <br/></td></tr>
<tr class="separator:a9e7296666267daedec965b147f9aa1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c243f8d541dc374ba38c0792285531b"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period , typename... Ts&gt; </td></tr>
<tr class="memitem:a9c243f8d541dc374ba38c0792285531b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9c243f8d541dc374ba38c0792285531b">delayed_send_tuple</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">channel_ptr</a> &amp;whom, const std::chrono::duration&lt; Rep, Period &gt; &amp;rtime, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:a9c243f8d541dc374ba38c0792285531b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to <code>whom</code> that is delayed by <code>rel_time</code>.  <a href="#a9c243f8d541dc374ba38c0792285531b">More...</a><br/></td></tr>
<tr class="separator:a9c243f8d541dc374ba38c0792285531b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff410e720bad0528c66d6e2f6eee1d45"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period , typename... Ts&gt; </td></tr>
<tr class="memitem:aff410e720bad0528c66d6e2f6eee1d45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aff410e720bad0528c66d6e2f6eee1d45">delayed_send</a> (const <a class="el" href="classcppa_1_1intrusive__ptr.html">channel_ptr</a> &amp;whom, const std::chrono::duration&lt; Rep, Period &gt; &amp;rtime, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:aff410e720bad0528c66d6e2f6eee1d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to <code>whom</code> that is delayed by <code>rel_time</code>.  <a href="#aff410e720bad0528c66d6e2f6eee1d45">More...</a><br/></td></tr>
<tr class="separator:aff410e720bad0528c66d6e2f6eee1d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9406a01669ed4787cefb44f7dac0e101"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period , typename... Ts&gt; </td></tr>
<tr class="memitem:a9406a01669ed4787cefb44f7dac0e101"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a9406a01669ed4787cefb44f7dac0e101">delayed_reply_tuple</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;rtime, <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> what)</td></tr>
<tr class="memdesc:a9406a01669ed4787cefb44f7dac0e101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a reply message that is delayed by <code>rel_time</code>.  <a href="#a9406a01669ed4787cefb44f7dac0e101">More...</a><br/></td></tr>
<tr class="separator:a9406a01669ed4787cefb44f7dac0e101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7d530f2c1d8e8c629e003981cad0a3"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period , typename... Ts&gt; </td></tr>
<tr class="memitem:a5d7d530f2c1d8e8c629e003981cad0a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5d7d530f2c1d8e8c629e003981cad0a3">delayed_reply</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;rtime, Ts &amp;&amp;...what)</td></tr>
<tr class="memdesc:a5d7d530f2c1d8e8c629e003981cad0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a reply message that is delayed by <code>rel_time</code>.  <a href="#a5d7d530f2c1d8e8c629e003981cad0a3">More...</a><br/></td></tr>
<tr class="separator:a5d7d530f2c1d8e8c629e003981cad0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3766bb0805c4b771f1b41d77f3f7a946"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3766bb0805c4b771f1b41d77f3f7a946"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_socket</b> = -1</td></tr>
<tr class="separator:a3766bb0805c4b771f1b41d77f3f7a946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd601df8b1aff0ef276f80a103c5f4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fd601df8b1aff0ef276f80a103c5f4e"></a>
constexpr <a class="el" href="structcppa_1_1anything.html">anything</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a6fd601df8b1aff0ef276f80a103c5f4e">any_vals</a> = <a class="el" href="structcppa_1_1anything.html">anything</a>{}</td></tr>
<tr class="memdesc:a6fd601df8b1aff0ef276f80a103c5f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches any number of any values. <br/></td></tr>
<tr class="separator:a6fd601df8b1aff0ef276f80a103c5f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea202e88a810b28d8c7370c5e058277b"><td class="memItemLeft" align="right" valign="top">constexpr __unspecified__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#aea202e88a810b28d8c7370c5e058277b">arg_match</a></td></tr>
<tr class="memdesc:aea202e88a810b28d8c7370c5e058277b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wildcard that matches the argument types of a given callback. Must be the last argument to <a class="el" href="namespacecppa.html#a25d0d9e15f20fe8a0644a1d137d27e90">on()</a>.  <a href="#aea202e88a810b28d8c7370c5e058277b">More...</a><br/></td></tr>
<tr class="separator:aea202e88a810b28d8c7370c5e058277b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d615a84f0e0e4eede5087ace98adfb"><td class="memItemLeft" align="right" valign="top">constexpr __unspecified__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a46d615a84f0e0e4eede5087ace98adfb">on_arg_match</a></td></tr>
<tr class="memdesc:a46d615a84f0e0e4eede5087ace98adfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left-hand side of a partial function expression.  <a href="#a46d615a84f0e0e4eede5087ace98adfb">More...</a><br/></td></tr>
<tr class="separator:a46d615a84f0e0e4eede5087ace98adfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3b8ac16de4477683b9640f277cbaef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e3b8ac16de4477683b9640f277cbaef"></a>
constexpr __unspecified__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a6e3b8ac16de4477683b9640f277cbaef">skip_message</a></td></tr>
<tr class="memdesc:a6e3b8ac16de4477683b9640f277cbaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-hand side expression to <em>not</em> match a particular pattern. <br/></td></tr>
<tr class="separator:a6e3b8ac16de4477683b9640f277cbaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241a516282529c45499a49101c35aa74"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>primitive_type_names</b> []</td></tr>
<tr class="separator:a241a516282529c45499a49101c35aa74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc77f5b27edd9e40908860db20e666d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdc77f5b27edd9e40908860db20e666d"></a>
<a class="el" href="classcppa_1_1local__actor.html">local_actor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#abdc77f5b27edd9e40908860db20e666d">self</a></td></tr>
<tr class="memdesc:abdc77f5b27edd9e40908860db20e666d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always points to the current actor. Similar to <code>this</code> in an object-oriented context. <br/></td></tr>
<tr class="separator:abdc77f5b27edd9e40908860db20e666d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a33b8a52fd7db5b67b1ef54590a4915d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33b8a52fd7db5b67b1ef54590a4915d4"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a33b8a52fd7db5b67b1ef54590a4915d4">no_spawn_options</a> = spawn_options::no_flags</td></tr>
<tr class="memdesc:a33b8a52fd7db5b67b1ef54590a4915d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes default settings. <br/></td></tr>
<tr class="separator:a33b8a52fd7db5b67b1ef54590a4915d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f021447f0bf5ed017ecc7246d2a961f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f021447f0bf5ed017ecc7246d2a961f"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a5f021447f0bf5ed017ecc7246d2a961f">monitored</a> = spawn_options::monitor_flag</td></tr>
<tr class="memdesc:a5f021447f0bf5ed017ecc7246d2a961f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes <code>spawn</code> to call <code>self-&gt;monitor(...)</code> immediately after the new actor was spawned. <br/></td></tr>
<tr class="separator:a5f021447f0bf5ed017ecc7246d2a961f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9b05086b21ddcff1c3a65314d01923"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b9b05086b21ddcff1c3a65314d01923"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a3b9b05086b21ddcff1c3a65314d01923">linked</a> = spawn_options::link_flag</td></tr>
<tr class="memdesc:a3b9b05086b21ddcff1c3a65314d01923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes <code>spawn</code> to call <code>self-&gt;link_to(...)</code> immediately after the new actor was spawned. <br/></td></tr>
<tr class="separator:a3b9b05086b21ddcff1c3a65314d01923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3d76a76f39ab461bb855a9317e7be3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e3d76a76f39ab461bb855a9317e7be3"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a3e3d76a76f39ab461bb855a9317e7be3">detached</a> = spawn_options::detach_flag</td></tr>
<tr class="memdesc:a3e3d76a76f39ab461bb855a9317e7be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the new actor to opt out of the cooperative scheduling. <br/></td></tr>
<tr class="separator:a3e3d76a76f39ab461bb855a9317e7be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c85d3242470c0e518b8ba2009dadb09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c85d3242470c0e518b8ba2009dadb09"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a1c85d3242470c0e518b8ba2009dadb09">hidden</a> = spawn_options::hide_flag</td></tr>
<tr class="memdesc:a1c85d3242470c0e518b8ba2009dadb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the runtime to ignore the new actor in <a class="el" href="namespacecppa.html#a185090573ffb146384ccdfa94172c23e">await_all_others_done()</a>. <br/></td></tr>
<tr class="separator:a1c85d3242470c0e518b8ba2009dadb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522ec04cb57018987ad6bfe5df75a023"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a522ec04cb57018987ad6bfe5df75a023"></a>
constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a522ec04cb57018987ad6bfe5df75a023">blocking_api</a> = spawn_options::blocking_api_flag</td></tr>
<tr class="memdesc:a522ec04cb57018987ad6bfe5df75a023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the new actor to opt in to the blocking API of libcppa, i.e., the actor uses a context-switching or thread-based backend instead of the default event-based implementation. <br/></td></tr>
<tr class="separator:a522ec04cb57018987ad6bfe5df75a023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b11e888dffba9f5b2fbca37eb83069"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecppa.html#a47b11e888dffba9f5b2fbca37eb83069">priority_aware</a></td></tr>
<tr class="memdesc:a47b11e888dffba9f5b2fbca37eb83069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the new actor to evaluate message priorities.  <a href="#a47b11e888dffba9f5b2fbca37eb83069">More...</a><br/></td></tr>
<tr class="separator:a47b11e888dffba9f5b2fbca37eb83069"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Root namespace of libcppa. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9ed5b5aa07c384b14899beae80974d47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacecppa.html#a64079da560a7bd85135c11ab521a4950">atom_value</a> cppa::atom </td>
          <td>(</td>
          <td class="paramtype">char const (&amp;)&#160;</td>
          <td class="paramname"><em>str</em>[Size]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an atom from given string literal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String constant representing an atom. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A compact representation of <code>str</code>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a1">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a185090573ffb146384ccdfa94172c23e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::await_all_others_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks execution of this actor until all other actors finished execution. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function will cause a deadlock if called from multiple actors. </dd>
<dd>
Do not call this function in cooperatively scheduled actors. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_2_8cpp-example.html#a4">announce_2.cpp</a>, <a class="el" href="announce_3_8cpp-example.html#a4">announce_3.cpp</a>, <a class="el" href="announce_4_8cpp-example.html#a7">announce_4.cpp</a>, <a class="el" href="announce_5_8cpp-example.html#a21">announce_5.cpp</a>, and <a class="el" href="dancing_kirby_8cpp-example.html#a7">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a5d7d530f2c1d8e8c629e003981cad0a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::delayed_reply </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a reply message that is delayed by <code>rel_time</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtime</td><td>Relative time duration to delay the message in microseconds, milliseconds, seconds or minutes. </td></tr>
    <tr><td class="paramname">what</td><td>Message elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacecppa.html#aff410e720bad0528c66d6e2f6eee1d45" title="Sends a message to whom that is delayed by rel_time.">delayed_send()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9406a01669ed4787cefb44f7dac0e101"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::delayed_reply_tuple </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a reply message that is delayed by <code>rel_time</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtime</td><td>Relative time duration to delay the message in microseconds, milliseconds, seconds or minutes. </td></tr>
    <tr><td class="paramname">what</td><td>Message content as a tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacecppa.html#aff410e720bad0528c66d6e2f6eee1d45" title="Sends a message to whom that is delayed by rel_time.">delayed_send()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aff410e720bad0528c66d6e2f6eee1d45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::delayed_send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcppa_1_1channel.html#ac7df8ed0bb6003f386e088bb0dedb1df">channel_ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message to <code>whom</code> that is delayed by <code>rel_time</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">rtime</td><td>Relative time duration to delay the message in microseconds, milliseconds, seconds or minutes. </td></tr>
    <tr><td class="paramname">what</td><td>Message elements. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a5">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a9c243f8d541dc374ba38c0792285531b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::delayed_send_tuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcppa_1_1channel.html#ac7df8ed0bb6003f386e088bb0dedb1df">channel_ptr</a> &amp;&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message to <code>whom</code> that is delayed by <code>rel_time</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">rtime</td><td>Relative time duration to delay the message in microseconds, milliseconds, seconds or minutes. </td></tr>
    <tr><td class="paramname">what</td><td>Message content as a tuple. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa221547ef879ba5b42f7cc7820f90e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T cppa::from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string created by <a class="el" href="namespacecppa.html#a76a9f2873d0e97eb7ceffb6101e8e507">to_string</a> to its original value. </p>
<p>Convenience function that deserializes a value from <code>what</code> and converts the result to <code>T</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>String representation of a serialized value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classcppa_1_1object.html">object</a> instance that contains the deserialized value.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the result is not of type <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The deserialized value as instance of <code>T</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a33344c46529f70febab48161c0c53a68"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Types &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacecppa.html#a5ab63f2274711ea5cce959c91d793b25">wildcard_position</a> cppa::get_wildcard_position </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the position of <a class="el" href="structcppa_1_1anything.html">anything</a> from the type list <code>Types</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>template parameter pack as <a class="el" href="structcppa_1_1util_1_1type__list.html">type_list</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28cd5b37281764af3f24ba8ca297c2f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> cppa::make_any_tuple </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classcppa_1_1any__tuple.html">any_tuple</a> containing the elements <code>args</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Values to initialize the tuple elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad65859efc090932630d14b226b9c9624"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">detail::match_helper cppa::match </td>
          <td>(</td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Tuple or value that should be matched against a pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="adaa18a8117e9022caea2b0606c11ebbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::match_helper cppa::match </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Tuple or value that should be matched against a pattern. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="abe0e5c70506e72b5f24d9fbb6dcc3c81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cppa::match_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; detail::match_each_helper&lt;InputIterator&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression that matches each element in range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element (excluded). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aae71367202afc39f91c6a3bb0337ba37"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename Projection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cppa::match_each </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Projection&#160;</td>
          <td class="paramname"><em>proj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; detail::match_each_helper&lt;InputIterator, Projection&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a match expression that matches <code>proj(i)</code> for each element <code>i</code> in range [first, last). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to the first element. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator to the last element (excluded). </td></tr>
    <tr><td class="paramname">proj</td><td>Projection or extractor functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A helper object providing <code>operator(...)</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a25d0d9e15f20fe8a0644a1d137d27e90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ cppa::on </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches values. </p>
<p>This overload can be used with the wildcards <a class="el" href="namespacecppa.html#af928936d573122345bc0737615f95f33">val</a>, <a class="el" href="namespacecppa.html#a6fd601df8b1aff0ef276f80a103c5f4e">any_vals</a> and <a class="el" href="namespacecppa.html#aea202e88a810b28d8c7370c5e058277b">arg_match</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a3">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="acb8c5c063a1758690748e20c805a76aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ cppa::on </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches types. </p>
<p>This overload matches types only. The type <a class="el" href="structcppa_1_1anything.html">anything</a> can be used as wildcard to match any number of elements of any types. </p>

</div>
</div>
<a class="anchor" id="a1341cd8bd16f4821146053de1093a732"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;atom_value... Atoms, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ cppa::on </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression that matches types. </p>
<p>This overload matches up to four leading atoms. The type <a class="el" href="structcppa_1_1anything.html">anything</a> can be used as wildcard to match any number of elements of any types. </p>

</div>
</div>
<a class="anchor" id="a487e6c08f5f4f7de4775418547f7e93e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppa_1_1actor.html#a15b74113cbde6221df8f00c25b6c2a56">actor_ptr</a>&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publishes <code>whom</code> at <code>port</code>. </p>
<p>The connection is automatically closed if the lifetime of <code>whom</code> ends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Actor that should be published at <code>port</code>. </td></tr>
    <tr><td class="paramname">port</td><td>Unused TCP port. </td></tr>
    <tr><td class="paramname">addr</td><td>The IP address to listen to, or <code>INADDR_ANY</code> if <code>addr</code> is <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcppa_1_1bind__failure.html" title="Thrown to indicate that an actor publishing failed because the requested port could not be used...">bind_failure</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9c73df0929df9b069096d3d9f9499bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppa_1_1actor.html#a15b74113cbde6221df8f00c25b6c2a56">actor_ptr</a>&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; network::acceptor &gt;&#160;</td>
          <td class="paramname"><em>acceptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Publishes <code>whom</code> using <code>acceptor</code> to handle incoming connections. </p>
<p>The connection is automatically closed if the lifetime of <code>whom</code> ends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Actor that should be published at <code>port</code>. </td></tr>
    <tr><td class="paramname">acceptor</td><td>Network technology-specific acceptor implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae213a56201820111919afe92aa287586"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::publish_local_groups_at </td>
          <td>(</td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>addr</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes <em>all</em> local groups accessible via network on address <code>addr</code> and <code>port</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classcppa_1_1bind__failure.html" title="Thrown to indicate that an actor publishing failed because the requested port could not be used...">bind_failure</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classcppa_1_1network__error.html" title="Thrown to indicate that either an actor publishing failed or libcppa was unable to connect to a remot...">network_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76739f7f372b92999ee9b80d332093bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::remote_actor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to the actor at <code>host</code> on given <code>port</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Valid hostname or IP address. </td></tr>
    <tr><td class="paramname">port</td><td>TCP port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e44ab5ef88ac98dd909f3a09bbf181d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::remote_actor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint16_t&#160;</td>
          <td class="paramname"><em>port</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to the actor at <code>host</code> on given <code>port</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Valid hostname or IP address. </td></tr>
    <tr><td class="paramname">port</td><td>TCP port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>

</div>
</div>
<a class="anchor" id="aa39f7d863455eec31681ebd1879e4fd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::remote_actor </td>
          <td>(</td>
          <td class="paramtype">network::io_stream_ptr_pair&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establish a new connection to the actor via given <code>connection</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">connection</td><td>A connection to another libcppa process described by a pair of input and output stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="">actor_ptr</a> to the proxy instance representing a remote actor. </dd></dl>

</div>
</div>
<a class="anchor" id="ace432faf00fa92965f1fbe94bb8f0eae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::reply </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message to the sender of the last received message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Message elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d847736b07a78186a20cd2b25e7fa47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::reply_tuple </td>
          <td>(</td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message to the sender of the last received message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Message content as a tuple. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a4dc7aa969b618f88f0571c0b8ea3d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::reply_tuple_to </td>
          <td>(</td>
          <td class="paramtype">const response_handle &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replies with <code>what</code> to <code>handle</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Identifies a previously received request. </td></tr>
    <tr><td class="paramname">what</td><td>Response message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef6af8d3fa6a39b766cac672c1ffcdf3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::send </td>
          <td>(</td>
          <td class="paramtype">destination_header&#160;</td>
          <td class="paramname"><em>hdr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <code>{what...}</code> to the receiver specified in <code>hdr</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>sizeof...(Ts) &gt; 0</code> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_2_8cpp-example.html#a3">announce_2.cpp</a>, <a class="el" href="announce_3_8cpp-example.html#a2">announce_3.cpp</a>, <a class="el" href="announce_4_8cpp-example.html#a6">announce_4.cpp</a>, <a class="el" href="announce_5_8cpp-example.html#a20">announce_5.cpp</a>, and <a class="el" href="dancing_kirby_8cpp-example.html#a0">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a03105d44e4e9056086a20f83f3a13929"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::send_as </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppa_1_1actor.html#a15b74113cbde6221df8f00c25b6c2a56">actor_ptr</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcppa_1_1channel.html#ac7df8ed0bb6003f386e088bb0dedb1df">channel_ptr</a>&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <code>{what...}</code> as a message to <code>whom</code>, but sets the sender information to <code>from</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Sender as seen by <code>whom</code>. </td></tr>
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">what</td><td>Message elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>sizeof...(Ts) &gt; 0</code> </dd></dl>

</div>
</div>
<a class="anchor" id="af7a903f4246f9e5bab78c06f666e8ee4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::send_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppa_1_1actor.html#a15b74113cbde6221df8f00c25b6c2a56">actor_ptr</a>&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an exit message to <code>whom</code> with <code>reason</code>. </p>
<p>This function is syntactic sugar for <code>send(whom, atom("EXIT"), reason)</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>reason != <a class="el" href="namespacecppa_1_1exit__reason.html#a68daf41064e58fe0302ca3becc85357d" title="Indicates that an actor finished execution.">exit_reason::normal</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f2a11054c90870f7f7bae3117845127"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::set_default_scheduler </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a thread pool scheduler with <code>num_threads</code> worker threads. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there's already a scheduler defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9fd959a7ff3c017ded6b64ee72dcec97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cppa::set_scheduler </td>
          <td>(</td>
          <td class="paramtype">scheduler *&#160;</td>
          <td class="paramname"><em>sched</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the scheduler to <code>sched</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched</td><td>A user-defined scheduler implementation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>sched != nullptr</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if there's already a scheduler defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5874085dfe88492adbc380b55c77053f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::spawn_cl </td>
          <td>(</td>
          <td class="paramtype">const opencl::program &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>local_dims</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code> from <code>prog</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if more than three dimensions are set, <code>dims.empty()</code>, or <code>clCreateKernel</code> failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a733d5a4394026abf6ddaba265f6970e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::spawn_cl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>local_dims</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles <code>source</code> and creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if more than three dimensions are set, <code>dims.empty()</code>, a compilation error occured, or <code>clCreateKernel</code> failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d7ec2cc77f30d3921a26fa21b902075"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapArgs , typename MapResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::spawn_cl </td>
          <td>(</td>
          <td class="paramtype">const opencl::program &amp;&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapArgs&#160;</td>
          <td class="paramname"><em>map_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapResult&#160;</td>
          <td class="paramname"><em>map_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>local_dims</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code> from <code>prog</code>, using <code>map_args</code> to extract the function arguments from incoming messages and <code>map_result</code> to transform the result before sending it as response. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if more than three dimensions are set, <code>dims.empty()</code>, or <code>clCreateKernel</code> failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae91e347999ca21eaf734024e45eff768"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapArgs , typename MapResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1intrusive__ptr.html">actor_ptr</a> cppa::spawn_cl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fun_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapArgs&#160;</td>
          <td class="paramname"><em>map_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MapResult&#160;</td>
          <td class="paramname"><em>map_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>offset</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const opencl::dim_vec &amp;&#160;</td>
          <td class="paramname"><em>local_dims</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compiles <code>source</code> and creates a new actor facade for an OpenCL kernel that invokes the function named <code>fname</code>, using <code>map_args</code> to extract the function arguments from incoming messages and <code>map_result</code> to transform the result before sending it as response. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if more than three dimensions are set, <code>dims.empty()</code>, a compilation error occured, or <code>clCreateKernel</code> failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a833551fceb9e2aa6200c35fb710bceb0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1message__future.html">message_future</a> cppa::sync_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppa_1_1actor.html#a15b74113cbde6221df8f00c25b6c2a56">actor_ptr</a>&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <code>{what...}</code> as a synchronous message to <code>whom</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">what</td><td>Message elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle identifying a future to the response of <code>whom</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned handle is actor specific and the response to the sent message cannot be received by another actor. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>sizeof...(Ts) &gt; 0</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>whom == nullptr</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54a3532bd3d67147a022ba56dc08fb41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1message__future.html">message_future</a> cppa::sync_send_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppa_1_1actor.html#a15b74113cbde6221df8f00c25b6c2a56">actor_ptr</a>&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <code>what</code> as a synchronous message to <code>whom</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">what</td><td>Message content as tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle identifying a future to the response of <code>whom</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned handle is actor specific and the response to the sent message cannot be received by another actor. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>whom == nullptr</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1d9479bd6f3e332a216d374540294f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1message__future.html">message_future</a> cppa::timed_sync_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppa_1_1actor.html#a15b74113cbde6221df8f00c25b6c2a56">actor_ptr</a>&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <code>{what...}</code> as a synchronous message to <code>whom</code> with a timeout. </p>
<p>The calling actor receives a 'TIMEOUT' message as response after given timeout exceeded and no response messages was received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">what</td><td>Message elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle identifying a future to the response of <code>whom</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned handle is actor specific and the response to the sent message cannot be received by another actor. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>sizeof...(Ts) &gt; 0</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>whom == nullptr</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43ed65c9a5a5e983cb510e4964e1942f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppa_1_1message__future.html">message_future</a> cppa::timed_sync_send_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppa_1_1actor.html#a15b74113cbde6221df8f00c25b6c2a56">actor_ptr</a>&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_tuple&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <code>what</code> as a synchronous message to <code>whom</code> with a timeout. </p>
<p>The calling actor receives a 'TIMEOUT' message as response after given timeout exceeded and no response messages was received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">what</td><td>Message content as tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle identifying a future to the response of <code>whom</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The returned handle is actor specific and the response to the sent message cannot be received by another actor. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>whom == nullptr</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76a9f2873d0e97eb7ceffb6101e8e507"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cppa::to_string </td>
          <td>(</td>
          <td class="paramtype">const atom_value &amp;&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>what</code> as a string representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Compact representation of an atom. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>what</code> as string. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_4_8cpp-example.html#a2">announce_4.cpp</a>, and <a class="el" href="announce_5_8cpp-example.html#a15">announce_5.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af928936d573122345bc0737615f95f33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__unspecified__ cppa::val </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wildcard that matches any value of type <code>T</code>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="">Math Actor Example</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_2_8cpp-example.html#a0">announce_2.cpp</a>, <a class="el" href="announce_3_8cpp-example.html#a0">announce_3.cpp</a>, and <a class="el" href="announce_4_8cpp-example.html#a0">announce_4.cpp</a>.</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="aea202e88a810b28d8c7370c5e058277b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr __unspecified__ cppa::arg_match</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wildcard that matches the argument types of a given callback. Must be the last argument to <a class="el" href="namespacecppa.html#a25d0d9e15f20fe8a0644a1d137d27e90">on()</a>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="">Math Actor Example</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a4">dancing_kirby.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a46d615a84f0e0e4eede5087ace98adfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr __unspecified__ cppa::on_arg_match</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left-hand side of a partial function expression. </p>
<p>Equal to <code>on(arg_match)</code>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="announce_5_8cpp-example.html#a14">announce_5.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a241a516282529c45499a49101c35aa74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* cppa::primitive_type_names[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    <span class="stringliteral">&quot;pt_int8&quot;</span>,        <span class="stringliteral">&quot;pt_int16&quot;</span>,       <span class="stringliteral">&quot;pt_int32&quot;</span>,       <span class="stringliteral">&quot;pt_int64&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_uint8&quot;</span>,       <span class="stringliteral">&quot;pt_uint16&quot;</span>,      <span class="stringliteral">&quot;pt_uint32&quot;</span>,      <span class="stringliteral">&quot;pt_uint64&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_float&quot;</span>,       <span class="stringliteral">&quot;pt_double&quot;</span>,      <span class="stringliteral">&quot;pt_long_double&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_u8string&quot;</span>,    <span class="stringliteral">&quot;pt_u16string&quot;</span>,   <span class="stringliteral">&quot;pt_u32string&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;pt_null&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a47b11e888dffba9f5b2fbca37eb83069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classcppa_1_1spawn__options.html">spawn_options</a> cppa::priority_aware</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= spawn_options::priority_aware_flag</div>
<div class="line">                                         + spawn_options::detach_flag</div>
</div><!-- fragment -->
<p>Causes the new actor to evaluate message priorities. </p>
<dl class="section note"><dt>Note</dt><dd>This implicitly causes the actor to run in its own thread. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 17 2013 08:53:05 for libcppa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
