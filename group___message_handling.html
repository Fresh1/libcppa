<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libcppa: Message handling.</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libcppa
   &#160;<span id="projectnumber">Version 0.1</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Message handling.</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ga844e75928ca8a1975a9d9bc9a7914913"></a><!-- doxytag: member="MessageHandling::send" ref="ga844e75928ca8a1975a9d9bc9a7914913" args="(channel_ptr &amp;whom, Arg0 const &amp;arg0, Args const &amp;...args)" -->
template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga844e75928ca8a1975a9d9bc9a7914913">cppa::send</a> (channel_ptr &amp;whom, Arg0 const &amp;arg0, Args const &amp;...args)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <code>{arg0, args...}</code> as a message to <code>whom</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">channel_ptr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga292e2922978c9f7bf6bb523ef8dddcc4">cppa::operator&lt;&lt;</a> (channel_ptr &amp;whom, any_tuple const &amp;what)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to <code>whom</code>.  <a href="#ga292e2922978c9f7bf6bb523ef8dddcc4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="gac38197c797cc60310e7104408397dab7"></a><!-- doxytag: member="MessageHandling::reply" ref="gac38197c797cc60310e7104408397dab7" args="(Arg0 const &amp;arg0, Args const &amp;...args)" -->
template&lt;typename Arg0 , typename... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#gac38197c797cc60310e7104408397dab7">cppa::reply</a> (Arg0 const &amp;arg0, Args const &amp;...args)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to the sender of the last received message. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Duration , typename... Data&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga2ccd53842321c3f22ea55c062ba9d752">cppa::future_send</a> (actor_ptr whom, Duration const &amp;rel_time, Data const &amp;...data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to <code>whom</code> that is delayed by <code>rel_time</code>.  <a href="#ga2ccd53842321c3f22ea55c062ba9d752"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Duration , typename... Data&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___message_handling.html#ga4f41270d7435edf680a7046dc4b061ba">cppa::delayed_reply</a> (Duration const &amp;rel_time, Data const ...data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a reply message that is delayed by <code>rel_time</code>.  <a href="#ga4f41270d7435edf680a7046dc4b061ba"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>This is the beating heart of <code>libcppa</code>. Actor programming is all about message handling.</p>
<p>A message in <code>libcppa</code> is a n-tuple of values (with size &gt;= 1). You can use almost every type in a messages.</p>
<h2><a class="anchor" id="Send"></a>
Send messages</h2>
<p>The function <code>send</code> could be used to send a message to an actor. The first argument is the receiver of the message followed by any number of values. <code>send</code> creates a tuple from the given values and enqueues the tuple to the receivers mailbox. Thus, send should <b>not</b> be used to send a message to multiple receivers. You should use the <code>enqueue</code> member function of the receivers instead as in the following example:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// spawn some actors</span>
 <span class="keyword">auto</span> a1 = <a class="code" href="group___actor_management.html#ga5dc6e0acd6a6fc6597161706de88f445" title="Spans a new context-switching actor.">spawn</a>(...);
 <span class="keyword">auto</span> a2 = <a class="code" href="group___actor_management.html#ga5dc6e0acd6a6fc6597161706de88f445" title="Spans a new context-switching actor.">spawn</a>(...);
 <span class="keyword">auto</span> a3 = <a class="code" href="group___actor_management.html#ga5dc6e0acd6a6fc6597161706de88f445" title="Spans a new context-switching actor.">spawn</a>(...);

 <span class="comment">// send a message to a1</span>
 <a class="code" href="group___message_handling.html#ga844e75928ca8a1975a9d9bc9a7914913" title="Sends {arg0, args...} as a message to whom.">send</a>(a1, <a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;hello&quot;</span>), <span class="stringliteral">&quot;hello a1!&quot;</span>);

 <span class="comment">// send a message to a1, a2 and a3</span>
 <span class="keyword">auto</span> msg = <a class="code" href="group___implicit_conversion.html#gaafb134a76b3aece293e96a69f6b4b312" title="Creates a new tuple from args.">make_tuple</a>(<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;compute&quot;</span>), 1, 2, 3);
 <span class="keyword">auto</span> s = <span class="keyword">self</span>; <span class="comment">// cache self pointer</span>
 <span class="comment">// note: this is more efficient then using send() three times because</span>
 <span class="comment">//       send() would create a new tuple each time;</span>
 <span class="comment">//       this safes both time and memory thanks to libcppa&#39;s copy-on-write</span>
 a1-&gt;enqueue(s, msg);
 a2-&gt;enqueue(s, msg);
 a3-&gt;enqueue(s, msg);

 <span class="comment">// modify msg and send it again</span>
 <span class="comment">// (msg becomes detached due to copy-on-write optimization)</span>
 get_ref&lt;1&gt;(msg) = 10; <span class="comment">// msg is now { atom(&quot;compute&quot;), 10, 2, 3 }</span>
 a1-&gt;enqueue(s, msg);
 a2-&gt;enqueue(s, msg);
 a3-&gt;enqueue(s, msg);
</pre></div><h2><a class="anchor" id="Receive"></a>
Receive messages</h2>
<p>The function <code>receive</code> takes a <code>behavior</code> as argument. The behavior is a list of { pattern &gt;&gt; callback } rules.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="namespacecppa.html#a671f171f6353ab9c5c859842a242faab" title="Dequeues the next message from the mailbox that&#39;s matched by bhvr and executes the corresponding call...">receive</a>
 (
     on&lt;<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;hello&quot;</span>), std::string&gt;() &gt;&gt; [](std::string <span class="keyword">const</span>&amp; msg)
     {
         cout &lt;&lt; <span class="stringliteral">&quot;received hello message: &quot;</span> &lt;&lt; msg &lt;&lt; endl;
     },
     <a class="code" href="namespacecppa.html#a05f825a376ebdeb341fb70f7abadb676" title="Left-hand side of a partial function expression that matches values.">on</a>&lt;<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;compute&quot;</span>), int, int, <span class="keywordtype">int</span>&gt;() &gt;&gt; [](<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2)
     {
         <span class="comment">// send our result back to the sender of this messages</span>
         <a class="code" href="group___message_handling.html#gac38197c797cc60310e7104408397dab7" title="Sends a message to the sender of the last received message.">reply</a>(<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;result&quot;</span>), i0 + i1 + i2);
     }
 );
</pre></div><p>The function <code>on</code> creates a pattern. It provides two ways of defining patterns: either by template parameters (prefixed by up to four atoms) or by arguments. The first way matches for types only (exept for the prefixing atoms). The second way compares values. Use the template function <code>val</code> to match for the type only.</p>
<p>This example is equivalent to the previous one but uses the second way to define patterns:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="namespacecppa.html#a671f171f6353ab9c5c859842a242faab" title="Dequeues the next message from the mailbox that&#39;s matched by bhvr and executes the corresponding call...">receive</a>
 (
     <a class="code" href="namespacecppa.html#a05f825a376ebdeb341fb70f7abadb676" title="Left-hand side of a partial function expression that matches values.">on</a>(<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;hello&quot;</span>), val&lt;std::string&gt;()) &gt;&gt; [](std::string <span class="keyword">const</span>&amp; msg)
     {
         cout &lt;&lt; <span class="stringliteral">&quot;received hello message: &quot;</span> &lt;&lt; msg &lt;&lt; endl;
     },
     <a class="code" href="namespacecppa.html#a05f825a376ebdeb341fb70f7abadb676" title="Left-hand side of a partial function expression that matches values.">on</a>(<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;compute&quot;</span>), val&lt;int&gt;(), val&lt;int&gt;(), val&lt;int&gt;()&gt;() &gt;&gt; [](<span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2)
     {
         <span class="comment">// send our result back to the sender of this messages</span>
         <a class="code" href="group___message_handling.html#gac38197c797cc60310e7104408397dab7" title="Sends a message to the sender of the last received message.">reply</a>(<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;result&quot;</span>), i0 + i1 + i2);
     }
 );
</pre></div><h2><a class="anchor" id="Atoms"></a>
Atoms</h2>
<p>Atoms are a nice way to add semantic informations to a message. Assuming an actor wants to provide a "math sevice" for integers. It could provide operations such as addition, subtraction, etc. This operations all have two operands. Thus, the actor does not know what operation the sender of a message wanted by receiving just two integers.</p>
<p>Example actor: </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> math_actor()
 {
     <a class="code" href="namespacecppa.html#a779def4c306e2d63d1cd74fe2d9d7cb1" title="Receives messages in an endless loop.">receive_loop</a>
     (
         on&lt;<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;plus&quot;</span>), <span class="keywordtype">int</span>, <span class="keywordtype">int</span>&gt;() &gt;&gt; [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)
         {
             <a class="code" href="group___message_handling.html#gac38197c797cc60310e7104408397dab7" title="Sends a message to the sender of the last received message.">reply</a>(<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;result&quot;</span>), a + b);
         },
         <a class="code" href="namespacecppa.html#a05f825a376ebdeb341fb70f7abadb676" title="Left-hand side of a partial function expression that matches values.">on</a>&lt;<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;minus&quot;</span>), int, <span class="keywordtype">int</span>&gt;() &gt;&gt; [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b)
         {
             <a class="code" href="group___message_handling.html#gac38197c797cc60310e7104408397dab7" title="Sends a message to the sender of the last received message.">reply</a>(<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;result&quot;</span>), a - b);
         }
     );
 }
</pre></div><h2><a class="anchor" id="ReceiveLoops"></a>
Receive loops</h2>
<p>Previous examples using <code>receive</code> create behaviors on-the-fly. This is inefficient in a loop since the argument passed to receive is created in each iteration again. It's possible to store the behavior in a variable and pass that variable to receive. This fixes the issue of re-creation each iteration but rips apart definition and usage.</p>
<p>There are four convenience functions implementing receive loops to declare behavior where it belongs without unnecessary copies: <code>receive_loop</code>, <code>receive_while</code>, <code>receive_for</code> and <code>do_receive</code>.</p>
<p><code>receive_loop</code> is analogous to <code>receive</code> and loops "forever" (until the actor finishes execution).</p>
<p><code>receive_while</code> creates a functor evaluating a lambda expression. The loop continues until the given lambda returns <code>false</code>. A simple example:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// receive two integers</span>
 vector&lt;int&gt; received_values;
 <a class="code" href="namespacecppa.html#af50e3deafdaddd7159f915841e7fe24c" title="Receives messages as long as stmt returns true.">receive_while</a>([&amp;]() { <span class="keywordflow">return</span> received_values.size() &lt; 2; })
 (
     on&lt;int&gt;() &gt;&gt; [](<span class="keywordtype">int</span> value)
     {
         received_values.push_back(value);
     }
 );
 <span class="comment">// ...</span>
</pre></div><p><code>receive_for</code> is a simple ranged-based loop:</p>
<div class="fragment"><pre class="fragment"> std::vector&lt;int&gt; vec {1, 2, 3, 4};
 <span class="keyword">auto</span> i = vec.begin();
 <a class="code" href="namespacecppa.html#a0d402548662057fa4d068a91f280a5bc" title="Receives messages as in a range-based loop.">receive_for</a>(i, vec.end())
 (
     <a class="code" href="namespacecppa.html#a05f825a376ebdeb341fb70f7abadb676" title="Left-hand side of a partial function expression that matches values.">on</a>(<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;get&quot;</span>)) &gt;&gt; [&amp;]() { <a class="code" href="group___message_handling.html#gac38197c797cc60310e7104408397dab7" title="Sends a message to the sender of the last received message.">reply</a>(<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;result&quot;</span>), *i); }
 );
</pre></div><p><code>do_receive</code> returns a functor providing the function <code>until</code> that takes a lambda expression. The loop continues until the given lambda returns true. Example:</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// receive ints until zero was received</span>
 vector&lt;int&gt; received_values;
 <a class="code" href="namespacecppa.html#ab32fd2e5649ee811c08a9ff74e9bed84" title="Receives messages until stmt returns true.">do_receive</a>
 (
     on&lt;int&gt;() &gt;&gt; [](<span class="keywordtype">int</span> value)
     {
         received_values.push_back(value);
     }
 )
 .until([&amp;]() { <span class="keywordflow">return</span> received_values.back() == 0 });
 <span class="comment">// ...</span>
</pre></div><h2><a class="anchor" id="FutureSend"></a>
Send delayed messages</h2>
<p>The function <code>future_send</code> provides a simple way to delay a message. This is particularly useful for recurring events, e.g., periodical polling. Usage example:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group___message_handling.html#ga2ccd53842321c3f22ea55c062ba9d752" title="Sends a message to whom that is delayed by rel_time.">future_send</a>(<span class="keyword">self</span>, std::chrono::seconds(1), <a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;poll&quot;</span>));
 <a class="code" href="namespacecppa.html#a779def4c306e2d63d1cd74fe2d9d7cb1" title="Receives messages in an endless loop.">receive_loop</a>
 (
     <span class="comment">// ...</span>
     on&lt;<a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;poll&quot;</span>)&gt;() &gt;&gt; []()
     {
         <span class="comment">// ... poll something ...</span>
         <span class="comment">// and do it again after 1sec</span>
         <a class="code" href="group___message_handling.html#ga2ccd53842321c3f22ea55c062ba9d752" title="Sends a message to whom that is delayed by rel_time.">future_send</a>(<span class="keyword">self</span>, std::chrono::seconds(1), <a class="code" href="namespacecppa.html#a9ed5b5aa07c384b14899beae80974d47" title="Creates an atom from given string literal.">atom</a>(<span class="stringliteral">&quot;poll&quot;</span>));
     }
 );
</pre></div><p>See also the <a class="el" href="dancing_kirby_8cpp-example.html">dancing kirby example</a>. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga4f41270d7435edf680a7046dc4b061ba"></a><!-- doxytag: member="cppa::delayed_reply" ref="ga4f41270d7435edf680a7046dc4b061ba" args="(Duration const &amp;rel_time, Data const ...data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Duration , typename... Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::delayed_reply </td>
          <td>(</td>
          <td class="paramtype">Duration const &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data const ...&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a reply message that is delayed by <code>rel_time</code>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___message_handling.html#ga2ccd53842321c3f22ea55c062ba9d752" title="Sends a message to whom that is delayed by rel_time.">future_send()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ccd53842321c3f22ea55c062ba9d752"></a><!-- doxytag: member="cppa::future_send" ref="ga2ccd53842321c3f22ea55c062ba9d752" args="(actor_ptr whom, Duration const &amp;rel_time, Data const &amp;...data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Duration , typename... Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cppa::future_send </td>
          <td>(</td>
          <td class="paramtype">actor_ptr&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Duration const &amp;&#160;</td>
          <td class="paramname"><em>rel_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data const &amp;...&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a message to <code>whom</code> that is delayed by <code>rel_time</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">whom</td><td>Receiver of the message. </td></tr>
    <tr><td class="paramname">rel_time</td><td>Relative time duration to delay the message. </td></tr>
    <tr><td class="paramname">data</td><td>Any number of values for the message content. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="dancing_kirby_8cpp-example.html#a4">dancing_kirby.cpp</a>, and <a class="el" href="dining_philosophers_8cpp-example.html#a6">dining_philosophers.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga292e2922978c9f7bf6bb523ef8dddcc4"></a><!-- doxytag: member="cppa::operator&lt;&lt;" ref="ga292e2922978c9f7bf6bb523ef8dddcc4" args="(channel_ptr &amp;whom, any_tuple const &amp;what)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">channel_ptr&amp; cppa::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">channel_ptr &amp;&#160;</td>
          <td class="paramname"><em>whom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">any_tuple const &amp;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a message to <code>whom</code>. </p>
<p><b>Usage example:</b> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">self</span> &lt;&lt; make_tuple(1, 2, 3);
</pre></div> <dl class="return"><dt><b>Returns:</b></dt><dd><code>whom</code>. </dd></dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 27 2012 19:45:54 for libcppa by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
